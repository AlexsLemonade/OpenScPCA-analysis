---
title: "Derive final annotations based on NBAtlas reference"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
params:
  scanvi_pp_threshold: 0.75    
  annotations_tsv: "results/SCPCP000004-annotations.tsv"
---

In this analysis module, we have annotated cell types in `SCPCP000004` samples using two methods: `SingleR` and `scANVI/scArches`, both using the `NBAtlas` dataset as a reference.
In this notebook, we derive the final annotations using information from the `SingleR` labels, the `scANVI/scArches` labels, and existing consensus cell type annotations.
All final annotations use labels present in the `NBAtlas` dataset.

We use the following approach to determine the final annotation.

First, we prioritize inferences with `SingleR` and `scANVI/scArches`.
If these methods returned the exact same label, we assign this label.

Next, we compare labels across all three methods: if at least _two out of three_ methods agree, we assign the agreeing label.
Note that this requires mapping consensus cell types to NBAtlas labels, which is only possible for these cell types: endothelial cells, fibroblasts, and immune cell types except for the `NBAtlas` labels `RBCs` and `pDC` which do not have corresponding consensus labels.

In this approach, there are two ways that cell type annotations can agree, and we treat them as follows:

* Cell type annotations can have directly corresponding labels. For example:
  * If the consensus cell type is `endothelial cell` and at least one of the `NBAtlas`-derived annotations is `Endothelial`, we assign the label `Endothelial`.
* Cell type annotations can differ but be in the same "family" of cell types. For example:
  * If the consensus cell type is `mature T cell` and at least one of the `NBAtlas`-derived annotations is `CD4+ T cell`, we assign the broader label `T cell`.
  * If one `NBAtlas`-derived annotation is `Patrolling monocyte` and the other is `Classical monocyte`, we assign the broader label `Monocyte`.

Finally, to the extent possible, we assign CL ontology IDs to the final annotations before export.

## Setup

```{r, warning = FALSE}
suppressPackageStartupMessages({
  library(ggplot2)
  library(patchwork)
  library(SingleCellExperiment)
})

theme_set(
  theme_bw() +
  theme(
    axis.text = element_blank(), 
    axis.ticks = element_blank(), 
    legend.position = "bottom", 
    aspect.ratio = 1
  )
)

# settings
options(
  dplyr.summarise.inform = FALSE, 
  readr.show_col_types = FALSE
)
```

### Functions


The function `get_unified_label()` defined in the chunk below determines a final label based on correspondence between at least two out of three labels, out of `SingleR`, `scANVI/scArches`, and the consensus label.


```{r}
#' Get unified cell type label
#'
#' @param annotation_df Data frame to annotate with columns `consensus`, `singler`, `scanvi`, and `cell_type_assignment`
#' @param consensus_options Vector of consensus cell types that match the final label, used for `consensus`
#' @param nbatlas_options Vector of NBAtlas cell types that match the final label, used for `singler` and `scanvi`
#' @param final_label Final label to apply if at least two methods have labels present in their respective vectors
#'
#' @returns Updated annotation_df with `cell_type_assignment` filled in with the `final_label` value where appropriate
get_unified_label <- function(
    annotation_df, 
    consensus_options, 
    nbatlas_options, 
    final_label) {
  
  annotation_df |>
    dplyr::mutate(
      # count how many annotations are in agreement
      n = consensus %in% consensus_options +
        singler %in% nbatlas_options + 
        scanvi %in% nbatlas_options, 
      # if >=2 agree, use this annotation
      cell_type_assignment = ifelse(
        is.na(cell_type_assignment) & n >= 2, 
        final_label, 
        cell_type_assignment
    )) |>
    dplyr::select(-n)
}
```

### Paths

```{r base paths}
module_dir <- rprojroot::find_root(rprojroot::is_renv_project)
repository_base <- file.path(module_dir, "..", "..")

data_dir <- file.path(repository_base, "data", "current", "SCPCP000004")
merged_dir <- file.path(repository_base, "data", "current", "results", "merge-sce", "SCPCP000004")
ref_dir <- file.path(module_dir, "references")
results_dir <- file.path(module_dir, "results")
singler_dir <- file.path(results_dir, "singler")
scanvi_dir <- file.path(results_dir, "scanvi")
```

```{r}
# Source additional utilities functions:
# - subset_nbatlas_markers()
# - harmonize_celltypes()
# - faceted_umap()
# - generate_dotplot()
source(file.path(module_dir, "scripts", "utils", "celltype-utils.R"))
```


```{r file paths}
# merged SCE file
sce_file <- file.path(
  merged_dir,
  "SCPCP000004_merged.rds"
)

# SingleR files
singler_files <- list.files(
  path = singler_dir,
  pattern = "_singler-annotations\\.tsv",
  recursive = TRUE,
  full.names = TRUE
) |>
  # add names as library id
  purrr::set_names(
    \(x) {
      stringr::str_remove(basename(x), "_singler-annotations.tsv")
    }
  )

# scanvi predictions
scanvi_file <- file.path(
  scanvi_dir, 
  "scanvi-predictions.tsv"
)

# palette file
palette_file <- file.path(
  module_dir,
  "palettes",
  "nbatlas-cell-type-palette.tsv"
)

# label map file
nbatlas_label_map_file <- file.path(
  ref_dir, 
  "nbatlas-label-map.tsv"
)

# label ontologies file
nbatlas_ontology_file <- file.path(
  ref_dir, 
  "nbatlas-ontology-ids.tsv"
)

# marker genes from NBAtlas
nbatlas_markers_file <- file.path(
  ref_dir, 
  "nbatlas-marker-genes.tsv"
)
```


### Read and prepare input data

Read merged SCE object:

```{r}
merged_sce <- readRDS(sce_file)
# immediately remove assays we don't need for space
assay(merged_sce, "spliced") <- NULL
assay(merged_sce, "counts") <- NULL
reducedDim(merged_sce, "PCA") <- NULL
```

Read SingleR results:

```{r}
singler_df <- singler_files |>
  purrr::map(readr::read_tsv) |>
  purrr::list_rbind(names_to = "library_id") |>
  dplyr::mutate(
    # add cell id column for unique rows & joining
    cell_id = glue::glue("{library_id}-{barcodes}"),
    # recode NA -> "Unknown"
    singler = ifelse(is.na(pruned.labels), "Unknown", pruned.labels)
  ) |>
  dplyr::select(cell_id, singler)
```

Read scANVI results:

```{r}
scanvi_df <- readr::read_tsv(
  file.path(scanvi_dir, "scanvi_predictions.tsv")
) |>
  dplyr::select(
    cell_id, 
    scanvi = scanvi_prediction, 
    starts_with("pp_")
  ) |>
  tidyr::pivot_longer(
    starts_with("pp_"), 
    names_to = "posterior_celltype", 
    values_to = "posterior"
  ) |>
  dplyr::mutate(posterior_celltype = stringr::str_remove(posterior_celltype, "^pp_")) |>
  dplyr::filter(scanvi == posterior_celltype) |>
  # recode to Unknown if below the threshold
  dplyr::mutate(scanvi = ifelse(posterior < params$scanvi_pp_threshold, "Unknown", scanvi)) |>
  dplyr::select(cell_id, scanvi)
```

Read additional helper files:

```{r}
palette_df <- readr::read_tsv(palette_file)
celltype_pal <- palette_df$hex_color
names(celltype_pal) <- palette_df$NBAtlas_label

label_map_df <- readr::read_tsv(nbatlas_label_map_file)
ontology_df <- readr::read_tsv(nbatlas_ontology_file)

nbatlas_markers_df <- readr::read_tsv(nbatlas_markers_file)
```


Combine annotations into a single data frame:

```{r}
celltype_df <- scuttle::makePerCellDF(
  merged_sce,
  use.coldata = c("sample_id", "is_xenograft", "consensus_celltype_annotation", "consensus_celltype_ontology")
) |>
  tibble::rownames_to_column("cell_id") |>
  tidyr::separate(cell_id, into = c("library_id", "cell_barcode"), remove = FALSE) |>
  # keep UMAP for eventual viz
  dplyr::rename(
    consensus = consensus_celltype_annotation, 
    consensus_ontology = consensus_celltype_ontology,
    UMAP1 = UMAP.1, 
    UMAP2 = UMAP.2
  ) |>
  dplyr::left_join(singler_df, by = "cell_id") |>
  dplyr::left_join(scanvi_df, by = "cell_id") 


# Pull out metadata we'll want later
sample_metadata <- celltype_df |>
  dplyr::select(sample_id, library_id, is_xenograft) |>
  unique()

# We can remove the merged_sce now
rm(merged_sce)
```


## Annotate

In this section, we'll derive the final annotations.

```{r}
ontology_slim_df <- ontology_df |>
  dplyr::select(-CL_annotation)

prep_for_annotation <- function(
    df, 
    annot_type, 
    ontology_df, 
    label_map_df) {
  
 df |>
    dplyr::select(all_of(c("cell_id", annot_type))) |>
    dplyr::rename(label = annot_type) |>
    # Join the family labels
    dplyr::left_join(label_map_df, by = c("label" = "NBAtlas_label_immune_zoom")) |>
    dplyr::rename(family_label = NBAtlas_label) |>
    # Ensure "Unknown" has a family label instead of NA for future-proofing
    dplyr::mutate(family_label = ifelse(is.na(family_label), "Unknown", family_label)) |>
    # Join in the ontology labels to match the **celltype** ontologies (label column)
    dplyr::left_join(ontology_slim_df, by = c("label" = "NBAtlas_label")) |>
    dplyr::rename(label_ontology = CL_ontology_id) |>
    # Join in the ontology labels to match the **family** ontologies (family_label column)
    dplyr::left_join(ontology_slim_df, by = c("family_label" = "NBAtlas_label")) |>
    dplyr::rename(family_ontology = CL_ontology_id) |>
    # We don't need the labels now that we have ontologies
    dplyr::select(-label, -family_label) |>
    # rename columns to start with `annot_type`
    dplyr::rename_with(\(x) {paste(annot_type, x, sep = "_")}, -cell_id)
}

singler_annotation_df <- prep_for_annotation(celltype_df, "singler", ontology_slim_df, label_map_df)
scanvi_annotation_df <- prep_for_annotation(celltype_df, "scanvi", ontology_slim_df, label_map_df)

annotation_df <- celltype_df |>
  dplyr::select(cell_id, consensus_ontology) |>
  dplyr::left_join(singler_annotation_df, by = "cell_id") |>
  dplyr::left_join(scanvi_annotation_df, by = "cell_id") |>
  dplyr::select(cell_id, consensus_ontology, starts_with("singler"), starts_with("scanvi"))
```


```{r}
annotation_df <- annotation_df |> 
  dplyr::mutate(
    CL_ontology_id = dplyr::case_when(
      # Use directly matching label
      scanvi_label_ontology == singler_label_ontology ~ scanvi_label_ontology, 
      # Check for family agreement between SingleR/scANVI
      scanvi_family_ontology == singler_family_ontology ~ scanvi_family_ontology,
      # Now use agreement with consensus to assign a label: first by label, and then by family
      singler_label_ontology == consensus_ontology ~ singler_label_ontology,
      scanvi_label_ontology == consensus_ontology ~ scanvi_label_ontology,
      singler_family_ontology == consensus_ontology ~ singler_family_ontology,
      scanvi_family_ontology == consensus_ontology ~ scanvi_family_ontology,
      # Everything else is NA
      .default = NA_character_
    )
  ) |>
  # keep only the final ontologies
  dplyr::select(cell_id, CL_ontology_id)


missing_cell_id <- annotation_df |>dplyr::filter(is.na(CL_ontology_id)) |>
  dplyr::pull(cell_id)

sjs_version <- readr::read_tsv(params$annotations_tsv)

stephyes_allyno <- sjs_version |>
  dplyr::filter(cell_id %in% missing_cell_id) |>
  dplyr::filter(!is.na(CL_ontology_id)) |>
  dplyr::pull(cell_id)

celltype_df |>
  dplyr::select(cell_id, singler, scanvi, consensus) |>
  dplyr::filter(cell_id %in% stephyes_allyno)
``` 


Next, we'll get unified labels for any cells where at least two of three methods agree.

```{r}
annotation_df <- annotation_df |>
  get_unified_label("fibroblast", "Fibroblast", "Fibroblast") |>
  get_unified_label("macrophage", "Macrophage", "Macrophage") |>
  get_unified_label("neutrophil", "Neutrophil", "Neutrophil") |>
  get_unified_label("plasma cell", "Plasma", "Plasma") |>
  get_unified_label(consensus_endo_celltypes, "Endothelial", "Endothelial") |>
  get_unified_label("natural killer cell", nbatlas_nk_celltypes, "NK cell") |>
  get_unified_label("monocyte", nbatlas_monocyte_celltypes, "Monocyte") |>
  get_unified_label("dendritic cell", nbatlas_cdc_celltypes, "cDC") |>
  get_unified_label(consensus_t_celltypes, nbatlas_t_celltypes, "T cell") |>
  # This must be last since it is the broadest category
  get_unified_label(consensus_myeloid_celltypes, nbatlas_myeloid_celltypes, "Myeloid")
```





## Explore final annotations

What fraction of cells have been annotated?

```{r}
sum(!is.na(annotation_df$CL_ontology_id)) / nrow(annotation_df)
```

What fraction of cells have been annotated per library?

```{r, fig.width = 8, fig.height = 4}
frac_labeled_df <- annotation_df |>
  tidyr::separate(cell_id, into = c("library_id", "barcode"), remove = FALSE) |>
  dplyr::group_by(library_id) |>
  dplyr::summarize(
    frac_labeled = sum(!is.na(cell_type_assignment))/dplyr::n(), 
    library_size = dplyr::n()
  ) |>
  # get PDX logical for coloring
  dplyr::inner_join(sample_metadata, by = "library_id")


p1 <- ggplot(frac_labeled_df) + 
  aes(x = frac_labeled) + 
  geom_histogram(bins = 40) +
  labs(x = "Fraction of library labeled") +
  theme_bw()


p2 <- ggplot(frac_labeled_df) + 
  aes(x = library_size, y = frac_labeled, color = is_xenograft) + 
  geom_point() + 
  labs(
    x = "Total cells in library",
    y = "Fraction of library labeled"
  ) +
  theme_bw() +
  theme(legend.position = "bottom")


p1 + p2
```

### UMAPs

In this section, we show the UMAP from the merged (not batch-corrected!) `SCPCP000004` object colored by cell type annotations and other potentially relevant metadata.


```{r}
# Finalize the annotations
submission_df <- annotation_df |>
  # add ontology ids
  dplyr::left_join(
    nbatlas_ontology_ids, 
    by = c("cell_type_assignment" = "NBAtlas_label")
  ) |>
  # recode labels
  dplyr::mutate(
    cell_type_assignment = dplyr::case_when(
      is.na(cell_type_assignment) ~ "Unknown", 
      cell_type_assignment == "NE" ~ "Neuroendocrine/tumor",
      .default = cell_type_assignment
   ),
    tumor_cell_classification = dplyr::case_when(
      cell_type_assignment == "Unknown" ~ "Unknown", 
      cell_type_assignment == "Neuroendocrine/tumor" ~ "tumor", 
      .default = "normal"
    )
  ) |>
  tidyr::separate(cell_id, into = c("library_id", "cell_barcode"), remove = FALSE) |>
  dplyr::select(
    cell_id, library_id, cell_barcode, cell_type_assignment, tumor_cell_classification, CL_ontology_id
  )
# update palette label as well
names(celltype_pal)[names(celltype_pal) == "Neuroendocrine"] <- "Neuroendocrine/tumor"
```



```{r}
# prepare data frame for plotting
umap_df <- celltype_df |>
  dplyr::select(cell_id, sample_id, library_id, is_xenograft, UMAP1, UMAP2) |>
  dplyr::left_join(submission_df, by = "cell_id") |>
  # group "same family" cell types in the factor for cleaner legend
  # note this will give warnings if any of those cells aren't in the final annotation, but that's fine
  dplyr::mutate(
    cell_type_assignment = factor(cell_type_assignment), 
    cell_type_assignment = forcats::fct_relevel(
      cell_type_assignment, 
      "T cell", nbatlas_t_celltypes, 
      "NK cell", nbatlas_nk_celltypes,
      "cDC", nbatlas_cdc_celltypes, 
      "Monocyte", nbatlas_monocyte_celltypes
    )
  )
```


#### Colored by cell type assignment

Note that in the UMAP below, cell types in the same "family" each share a color:

* T cells: `T cell`, `Treg`, `CD4+ T cell`, `CD8+ T cell`
* Natural killer cells: `NK cell`, `Circulating NK cell`, `Resident NK cell`, `TOX2+/KIT+ NK cell`
* Conventional dendritic cells: `cDC`, `cDC1`, `cDC2/DC3`, `Migratory cDC`
* Monocytes: `Monocyte`, `Classical monocyte`, `Patrolling monocyte`

```{r fig.width = 10, fig.height = 10}
ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = cell_type_assignment) +
  geom_point(alpha = 0.2, size = 0.3) +
  scale_color_manual(values = celltype_pal) +
guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```

#### Faceted by cell type assignment

This UMAP is the same as the previous one, except each facet highlights one specific cell type.


```{r fig.width = 16, fig.height = 16}
umap_df |>
  faceted_umap(
    annotation_column = cell_type_assignment,
    celltype_colors = celltype_pal
  )
```


#### Colored by tumor classification


```{r fig.width = 8, fig.height = 8}
ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = tumor_cell_classification) +
  geom_point(alpha = 0.2, size = 0.3) +
  scale_color_brewer(palette = "Set2") +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```

#### Colored by PDX status

```{r fig.width = 8, fig.height = 8}
ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = is_xenograft) +
  geom_point(alpha = 0.2, size = 0.3) +
  scale_color_brewer(palette = "Set1") +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```


### Dot plot

This section shows dot plots of marker gene expression for the final annotations.
Specifically, we show the top 5 highest `log2FC` marker genes per NBAtlas cell type for validation.
Marker genes that are present in three or more cell types are not included.
Marker genes are taken directly from the NBAtlas paper where they were identified with `Seurat::FindMarkers()`. 

```{r}
# data frame of top 5 upregulated genes per cell type
top_nbatlas_markers_df <- subset_nbatlas_markers(nbatlas_markers_df, 5, "up") |>
  # only markers in no more than 2 categories
  # this is a good middle ground to ensure there are at least 2 markers per cell type
  dplyr::add_count(ensembl_gene_id) |>
  dplyr::filter(n < 3) |>
  dplyr::select(-n) 
```


```{r, fig.width = 24, fig.height = 12}

# get total number of cells per final annotation group and set up y_label
total_cells_df <- full_celltype_df |>
  dplyr::count(label, name = "total_cells") |>
  # order so cell types are grouped
  dplyr::inner_join(label_map_df, by = "label" ) |>
  dplyr::mutate(
    label_recoded = as.factor(label_recoded),
    label_recoded = forcats::fct_relevel(label_recoded, levels(label_recoded_factor))
  ) |>
  dplyr::arrange(label_recoded) |>
  dplyr::mutate(y_label = glue::glue("{label} ({total_cells})")) |>
  # rename as expected for dotplot function - label_recoded needs to be the main column
  dplyr::select(-label_recoded) |>
  dplyr::rename(label_recoded = label)


total_cells_df$y_label <- factor(total_cells_df$y_label, levels = rev(total_cells_df$y_label))
nbatlas_bar_order <- total_cells_df$label_recoded
```


```{r, fig.width = 32, fig.height = 16}
generate_dotplot(
  merged_sce = merged_sce,
  markers_df = top_nbatlas_markers_df,
  # rename this after we've done all the wrangling
  singler_df = full_celltype_df |> dplyr::rename(label_recoded = label),
  total_cells_df = total_cells_df,
  expressed_genes = expressed_genes,
  bar_order = nbatlas_bar_order, 
  celltype_palette = nbatlas_celltype_pal, 
  min_cells = 0
)
```


## Export

```{r}
readr::write_tsv(
  submission_df,
  params$annotations_tsv
)
```

## Session Info

```{r}
sessionInfo()
```
