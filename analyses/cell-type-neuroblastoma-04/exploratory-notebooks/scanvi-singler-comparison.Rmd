---
title: "Compare scANVI and SingleR annotations"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
---

We have used `SingleR` and `scANVI/scArches` to perform cell type annotation on `SCPCP000004` samples using the `NBAtlas` reference.
The goal of this notebook is to compare these two sets of inferences to determine if they generally agree.
   
## Setup

```{r, warning = FALSE}
suppressPackageStartupMessages({
  library(ggplot2)
  library(patchwork)
  library(SingleCellExperiment)
})

theme_set(theme_bw())

# Define color ramp for shared use in the heatmaps
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))
# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.6, "in"))

# settings
options(
  dplyr.summarise.inform = FALSE, 
  readr.show_col_types = FALSE
)
```


### Paths

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

merged_dir <- file.path(repository_base, "data", "current", "results", "merge-sce", "SCPCP000004")
module_dir <- file.path(repository_base, "analyses", "cell-type-neuroblastoma-04")
ref_dir <- file.path(module_dir, "references")
results_dir <- file.path(module_dir, "results")
singler_dir <- file.path(results_dir, "singler")
scanvi_dir <- file.path(results_dir, "scanvi")
```


```{r file paths}
# merged SCE file
sce_file <- file.path(
  merged_dir,
  "SCPCP000004_merged.rds"
)

# SingleR files
singler_files <- list.files(
  path = singler_dir,
  pattern = "_singler-annotations\\.tsv",
  recursive = TRUE,
  full.names = TRUE
) |>
  # add names as library id
  purrr::set_names(
    \(x) {
      stringr::str_remove(basename(x), "_singler-annotations.tsv")
    }
  )

# scanvi predictions
scanvi_file <- file.path(
  scanvi_dir, 
  "scanvi-predictions.tsv"
)

# broad consensus cell type groups
validation_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-validation-groups.tsv"

# palette files
recoded_palette_file <- file.path(
  module_dir,
  "palettes",
  "harmonized-cell-type-palette.tsv"
)
nbatlas_palette_file <- file.path(
  module_dir,
  "palettes",
  "nbatlas-plus-cell-type-palette.tsv"
)
```

### Functions

```{r}
# Source Jaccard and heatmap utilities functions
source(file.path(module_dir, "scripts", "utils", "jaccard-utils.R"))

# Source additional utilities functions:
# - select_nbatlas_markers()
# - harmonize_celltypes()
# - faceted_umap()
# - generate_dotplot()
source(file.path(module_dir, "scripts", "utils", "celltype-utils.R"))
```

### Read and prepare input data

Read merged SCE object:

```{r}
merged_sce <- readRDS(sce_file)
# immediately remove assays we don't need for space
assay(merged_sce, "spliced") <- NULL
assay(merged_sce, "counts") <- NULL
reducedDim(merged_sce, "PCA") <- NULL
```

Read SingleR results:

```{r}
singler_df <- singler_files |>
  purrr::map(readr::read_tsv) |>
  purrr::list_rbind(names_to = "library_id") |>
  dplyr::mutate(
    # add cell id column for unique rows & joining
    cell_id = glue::glue("{library_id}-{barcodes}"),
    # recode NA -> "unknown_singler"
    singler = ifelse(is.na(pruned.labels),"unknown_singler", pruned.labels)
  ) |>
  dplyr::select(cell_id, singler, singler_delta_next = delta.next)
```

Read and prepare scanvi results:

```{r}
scanvi_full_df <- readr::read_tsv(
  file.path(scanvi_dir, "scanvi_predictions.tsv")
) |>
  dplyr::select(
    cell_id, 
    scanvi = scanvi_prediction, 
    starts_with("pp_")
  ) |>
  tidyr::pivot_longer(
    starts_with("pp_"), 
    names_to = "posterior_celltype", 
    values_to = "posterior"
  ) |>
  dplyr::mutate(posterior_celltype = stringr::str_remove(posterior_celltype, "^pp_"))

# create dedicated column for the posterior associated with the label
scanvi_df <- scanvi_full_df |>
  dplyr::filter(scanvi == posterior_celltype) |>
  dplyr::select(cell_id, scanvi, scanvi_posterior = posterior)
```


Read and prepare additional helper files for viz:

```{r}
# validation groups data frame
validation_df <- readr::read_tsv(validation_url) |>
  dplyr::select(consensus_annotation, validation_group_annotation)

# set up palettes
recoded_palette_df <- readr::read_tsv(recoded_palette_file)
recoded_celltype_pal <- recoded_palette_df$hex_color
names(recoded_celltype_pal) <- recoded_palette_df$harmonized_label

nbatlas_palette_df <- readr::read_tsv(nbatlas_palette_file)
nbatlas_celltype_pal <- nbatlas_palette_df$hex_color
names(nbatlas_celltype_pal) <- nbatlas_palette_df$NBAtlas_label
```


## scANVI posterior probabilities

Before comparing to `SingleR`, we should get a sense of reliability for the `scANVI` results.
`scANVI` returns a cell-specific posterior probability for each label, so we'll begin by looking at these distributions.

First, what is the distribution of posterior probabilities for assigned labels?
We'll make a histogram below using a very visible color to ensure the plot is legible, where each panel is a library, and libraries are ordered by size.

```{r fig.height=12, fig.width=15}
scanvi_df |>
  tidyr::separate(cell_id, into = c("library_id", "barcode"), remove = FALSE) |>
  dplyr::add_count(library_id) |>
  dplyr::mutate(
    library_id = glue::glue("{library_id} (N={n})"),
    library_id = factor(library_id), 
    library_id = forcats::fct_infreq(library_id), 
    library_id = forcats::fct_rev(library_id)
  ) |>
  ############ into ggplot ################
  ggplot() + 
  aes(x = scanvi_posterior) + 
  # ugly but _very visible_ color
  geom_histogram(bins = 100, fill = "magenta", color = "magenta") + 
  facet_wrap(vars(library_id), scales = "free_y", ncol = 7)
```


Across libraries, the median posterior probability is always exceptionally high at which suggests `scANVI` confidence is roughly the same across libraries.

Let's instead look at these probabilities on a per-cell type basis, this time with a ridge plot including a line for the median value for each distribution:

```{r fig.height=8, fig.width=8}
scanvi_ridgeplot <- scanvi_df |>
  dplyr::group_by(scanvi) |>
  dplyr::mutate(scanvi = glue::glue("{scanvi} (n={dplyr::n()})")) |>
  ########### into ggplot ############
  ggplot() + 
    aes(y = forcats::fct_infreq(scanvi), x = scanvi_posterior) + 
    # show the median
    ggridges::stat_density_ridges(quantile_lines = TRUE, quantiles = 2, alpha = 0.7) +
    labs(x = "posterior probability", y = "scANVI label (number of cells)") 
scanvi_ridgeplot
```

While annotation reliability is about the same on a per-library basis, it seems that certain cell types may be much easier to classify than others which may be a factor of how well represented they are in the `NBAtlas` reference.
There are very few cells in general associated with the cell types that have very low median posterior probabilities (`NKT cell`, `Migratory cDC`, `Circulating NK cell`).

A `0.75` threshold seems like it may be a good middle-ground for preserving labels while removing low-confidence annotations:

```{r fig.height=8, fig.width=8}
scanvi_ridgeplot +
  geom_vline(xintercept = 0.75, color = "firebrick")
```


How many cells will this remove?

```{r}
sum(scanvi_df$scanvi_posterior < 0.75) / nrow(scanvi_df)
```

What are those cell types?

```{r}
scanvi_df |>
  dplyr::filter(scanvi_posterior < 0.75) |>
  dplyr::count(scanvi) |>
  dplyr::arrange(desc(n))
```


We'll therefore recode cells with posterior probabilities below 0.75 to `unknown_scanvi`.

```{r}
pp_threshold <- 0.75
scanvi_df <- scanvi_df |>
  dplyr::mutate(scanvi = ifelse(
    scanvi_posterior < pp_threshold, 
    "unknown_scanvi",
    scanvi
  ))
```

## Compare labels

We'll create a single data frame with UMAP coordinates and all cell types (consensus, `SingleR`, and `scANVI`). 

```{r}
celltype_df <- scuttle::makePerCellDF(
  merged_sce,
  use.coldata = c("sample_id", "consensus_celltype_annotation"),
  use.dimred = c("UMAP")
) |>
  # there ARE repeated barcodes so we need to keep cell_id around
  tibble::rownames_to_column("cell_id") |>
  dplyr::rename(
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2,
    consensus_annotation = consensus_celltype_annotation
  ) |>
  dplyr::left_join(validation_df, by = "consensus_annotation") |>
  # recode consensus NAs to "unknown_consensus"
  dplyr::mutate(
    validation_group_annotation = ifelse(
      is.na(validation_group_annotation), "unknown_consensus", validation_group_annotation
    )
  ) |>
  dplyr::select(-consensus_annotation) |>
  # merge in the annotations
  dplyr::left_join(singler_df, by = "cell_id") |>
  dplyr::left_join(scanvi_df, by = "cell_id") |>
  # make it tidy
  tidyr::pivot_longer(
    c(validation_group_annotation, singler, scanvi), 
    names_to = "celltype_method", 
    values_to = "label"
  ) |>
  harmonize_celltypes(label, label_recoded) 
```


## UMAP

This section displays the UMAP for the _merged object_ (not integrated) with cell type labels harmonized for comparison.
We show a panel for each cell type method.

```{r, fig.width = 12, fig.height = 8}
ggplot(celltype_df) +
  aes(x = UMAP1, y = UMAP2, color = label_recoded) +
  geom_point(alpha = 0.5, size = 0.2) +
  scale_color_manual(values = recoded_celltype_pal) +
  facet_wrap(vars(celltype_method)) +
  coord_equal() +
  theme(
    legend.position = "bottom", 
    axis.text = element_blank(), 
    axis.ticks = element_blank()
  ) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```


## Heatmap

This section shows a stacked heatmap comparing the `SingleR` and `scANVI` annotations to the consensus validation groups.

```{r, fig.height = 13, fig.width = 12} 
# make a wide version for the heatmap
celltype_wide_df <- celltype_df |>
  dplyr::select(-label) |>
  tidyr::pivot_wider(
    names_from = celltype_method,
    values_from = label_recoded
  )

list(
  "SingleR annotations" = make_jaccard_matrix(celltype_wide_df, "validation_group_annotation", "singler"),
  "scANVI annotations" = make_jaccard_matrix(celltype_wide_df, "validation_group_annotation", "scanvi")
) |>
  purrr::imap(
    \(jaccard_mat, name) create_single_heatmap(
        mat = jaccard_mat,
        row_title = name,
        column_title = "Consensus validation groups",
        keep_legend_name = "SingleR annotations" # arbitrary
    )
  ) |>
  # concatenate vertically into HeatmapList object
  purrr::reduce(ComplexHeatmap::`%v%`) |>
  ComplexHeatmap::draw(heatmap_legend_side = "right")
```


We'll also show some statistics from a confusion matrix comparison between `SingleR` and `scANVI`:

```{r}
# ensure factors are compatible for caret
all_levels <- c(
  celltype_wide_df$scanvi, 
  celltype_wide_df$singler
) |> unique()

caret::confusionMatrix(
  factor(celltype_wide_df$scanvi, levels = all_levels),  
  factor(celltype_wide_df$singler, levels = all_levels)
)$overall

```

## Cross-library comparison

Across libraries, what fraction of `SingleR` and `scANVI` labels exactly agree?
Note that this analysis does not consider similar labels (e.g. two types of T cells) but only does a quick look at identical labels.
We'll also highlight the PDX samples here to see if there was any associated bias.


```{r, fig.width = 10, fig.height = 4}
frac_agree_df <- celltype_wide_df |>
  tidyr::separate(cell_id, into = c("library_id", "barcode")) |>
  dplyr::group_by(library_id) |>
  dplyr::summarize(
    frac_agree = sum(scanvi == singler)/dplyr::n(), 
    library_size = dplyr::n()
  )
frac_agree_df <- colData(merged_sce) |> 
  as.data.frame() |> 
  dplyr::select(library_id, is_xenograft) |> 
  unique() |>
  dplyr::right_join(frac_agree_df, by = "library_id")


p1 <- ggplot(frac_agree_df) + 
  aes(x = frac_agree) + 
  geom_histogram() + 
  xlab("Fraction of SingleR and scANVI cells\nthat agree, per library")

p2 <- ggplot(frac_agree_df) + 
  aes(x = library_size, y = frac_agree, color = is_xenograft) + 
  geom_point() +
  labs(
    x = "Library size (n cells)",
    y = "Fraction of SingleR and scANVI\ncells that agree"
  ) +
  theme(legend.position = "bottom")

p1 + p2

```

## Conclusions

Overall `SingleR` and `scANVI` appear to have made highly similar predictions for the vast majority of libraries.
These cell types are also fairly similar to our existing consensus cell types.
Therefore, we can use agreement between `SingleR` and `scANVI` to derive final annotations for this analysis module.


```{r}
sessionInfo()
```
