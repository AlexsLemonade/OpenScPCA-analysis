---
title: "Compare scANVI and SingleR annotations"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
---

We have used `SingleR` and `scANVI/scArches` to perform cell type annotation on `SCPCP000004` samples using the `NBAtlas` reference.
The goal of this notebook is to compare these two sets of inferences to determine if they generally agree.
   
## Setup

```{r, warning = FALSE}
suppressPackageStartupMessages({
  library(ggplot2)
  library(patchwork)
  library(SingleCellExperiment)
})

theme_set(theme_bw())

# Define color ramp for shared use in the heatmaps
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))
# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.6, "in"))

# settings
options(
  dplyr.summarise.inform = FALSE, 
  readr.show_col_types = FALSE
)
```


### Paths

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

merged_dir <- file.path(repository_base, "data", "current", "results", "merge-sce", "SCPCP000004")
module_dir <- file.path(repository_base, "analyses", "cell-type-neuroblastoma-04")
ref_dir <- file.path(module_dir, "references")
results_dir <- file.path(module_dir, "results")
singler_dir <- file.path(results_dir, "singler")
scanvi_dir <- file.path(results_dir, "scanvi")
```


```{r file paths}
# merged SCE file
sce_file <- file.path(
  merged_dir,
  "SCPCP000004_merged.rds"
)

# SingleR files
singler_files <- list.files(
  path = singler_dir,
  pattern = "_singler-annotations\\.tsv",
  recursive = TRUE,
  full.names = TRUE
) |>
  # add names as library id
  purrr::set_names(
    \(x) {
      stringr::str_remove(basename(x), "_singler-annotations.tsv")
    }
  )

# scanvi predictions
scanvi_file <- file.path(
  scanvi_dir, 
  "scanvi-predictions.tsv"
)


# broad consensus cell type groups
validation_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-validation-groups.tsv"

# palette files
recoded_palette_file <- file.path(
  module_dir,
  "palettes",
  "harmonized-cell-type-palette.tsv"
)
```

### Functions

```{r}
# Source Jaccard and heatmap utilities functions
source(file.path(module_dir, "scripts", "utils", "jaccard-utils.R"))

# Source additional utilities functions:
# - select_nbatlas_markers()
# - harmonize_celltypes()
# - faceted_umap()
# - generate_dotplot()
source(file.path(module_dir, "scripts", "utils", "celltype-utils.R"))
```

### Read and prepare input data

Read merged SCE object:

```{r}
merged_sce <- readRDS(sce_file)
# immediately remove assays we don't need for space
assay(merged_sce, "spliced") <- NULL
assay(merged_sce, "counts") <- NULL
reducedDim(merged_sce, "PCA") <- NULL
```

Read SingleR results:

```{r}
singler_df <- singler_files |>
  purrr::map(readr::read_tsv) |>
  purrr::list_rbind(names_to = "library_id") |>
  dplyr::mutate(
    # add cell id column for unique rows & joining
    cell_id = glue::glue("{library_id}-{barcodes}"),
    # recode NA -> "unknown_singler"
    singler = ifelse(is.na(pruned.labels),"unknown_singler", pruned.labels)
  ) |>
  dplyr::select(cell_id, singler, singler_delta_next = delta.next)
```

Read and prepare scanvi results:

```{r}
scanvi_full_df <- readr::read_tsv(
  file.path(scanvi_dir, "scanvi_predictions.tsv")
) |>
  dplyr::select(
    cell_id, 
    scanvi = scanvi_prediction, 
    starts_with("pp_")
  ) |>
  tidyr::pivot_longer(
    starts_with("pp_"), 
    names_to = "posterior_celltype", 
    values_to = "posterior"
  ) |>
  dplyr::mutate(posterior_celltype = stringr::str_remove(posterior_celltype, "^pp_"))

# create dedicated column for the posterior associated with the label
scanvi_df <- scanvi_full_df |>
  dplyr::filter(scanvi == posterior_celltype) |>
  dplyr::select(cell_id, scanvi, scanvi_posterior = posterior)
```


Read and prepare additional helper files for viz:

```{r}
# validation groups data frame
validation_df <- readr::read_tsv(validation_url) |>
  dplyr::select(consensus_annotation, validation_group_annotation)

# set up palettes
# recoded to shared colors
recoded_palette_df <- readr::read_tsv(recoded_palette_file)
recoded_celltype_pal <- recoded_palette_df$hex_color
names(recoded_celltype_pal) <- recoded_palette_df$harmonized_label
```


## scANVI posterior probabilities

Before comparing to `SingleR`, we should get a sense of reliability for the `scANVI` results.
`scANVI` returns a cell-specific posterior probability for each label, so we'll begin by looking at these distributions.

First, what is the distribution of posterior probabilities for assigned labels?
We'll look at this on a per-library basis to see if any libraries may have less confident annotations in general.

```{r fig.height=12, fig.width=15}
scanvi_df |>
  tidyr::separate(cell_id, into = c("library_id", "barcode"), remove = FALSE) |>
  dplyr::add_count(library_id) |>
  dplyr::mutate(library_id = glue::glue("{library_id} (N={n})")) |>
  ############ into ggplot ################
  ggplot() + 
  aes(x = scanvi_posterior) + 
  # ugly but _very visible_ color
  geom_histogram(bins = 100, fill = "magenta", color = "magenta") + 
  facet_wrap(vars(library_id), scales = "free_y", ncol = 7)
```


The posterior probabilities here are all _exceptionally_ high, consistently across all libraries, which tells us that on the whole, `scANVI` is confident in assignments.

Let's instead look at these probabilities on a per-cell type basis:

```{r fig.height=8, fig.width=12}
ggplot(scanvi_df) + 
  aes(x = scanvi_posterior) + 
  # ugly but _very visible_ color
  geom_histogram(bins = 100, fill = "magenta", color = "magenta") + 
  facet_wrap(vars(scanvi), scales = "free_y", ncol = 5) 
```

While annotation reliability is about the same on a per-library basis, it seems that certain cell types may be much easier to classify than others which may be a factor of how well represented they are in the `NBAtlas` reference.
We'll look at the median value for each as well as the number of cells that were annotated for each label:

```{r}
scanvi_df |>
  dplyr::group_by(scanvi) |>
  dplyr::summarize(
    median_pp = median(scanvi_posterior), 
    total_cells = dplyr::n()
  ) |>
  dplyr::arrange(median_pp)
```

There are very few cells in general associated with the cell types that have very low median posterior probabilities (`NKT cell` and `Migratory cDC`), which is comforting.

A `0.9` threshold for the posterior probability here seems reasonable given how high these values are in general. 
We'll therefore recode cells with posterior probabilities below 0.9 to `unknown_scanvi`.

```{r}
pp_threshold <- 0.9
scanvi_df <- scanvi_df |>
  dplyr::mutate(scanvi = ifelse(
    scanvi_posterior < pp_threshold, 
    "unknown_scanvi",
    scanvi
  ))
```

## Compare labels

We'll create a single data frame with UMAP coordinates and all cell types (consensus, `SingleR`, and `scANVI`):

```{r}
celltype_df <- scuttle::makePerCellDF(
  merged_sce,
  use.coldata = c("sample_id", "consensus_celltype_annotation"),
  use.dimred = c("UMAP")
) |>
  # there ARE repeated barcodes so we need to keep cell_id around
  tibble::rownames_to_column("cell_id") |>
  dplyr::rename(
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2,
    consensus_annotation = consensus_celltype_annotation
  ) |>
  dplyr::left_join(validation_df, by = "consensus_annotation") |>
  # recode consensus NAs to "unknown_consensus"
  dplyr::mutate(
    validation_group_annotation = ifelse(
      is.na(validation_group_annotation), "unknown_consensus", validation_group_annotation
    )
  ) |>
  dplyr::select(-consensus_annotation) |>
  # merge in the annotations
  dplyr::left_join(singler_df, by = "cell_id") |>
  dplyr::left_join(scanvi_df, by = "cell_id") |>
  # make it tidy
  tidyr::pivot_longer(
    c(validation_group_annotation, singler, scanvi), 
    names_to = "celltype_method", 
    values_to = "label"
  ) |>
  harmonize_celltypes(label, label_recoded) 
```


## UMAP

This section displays the UMAP for the _merged object_ (not integrated) with cell type labels harmonized for comparison.
We show a panel for each cell type method.

```{r, fig.width = 12, fig.height = 8}
ggplot(celltype_df) +
  aes(x = UMAP1, y = UMAP2, color = label_recoded) +
  geom_point(alpha = 0.5, size = 0.2) +
  scale_color_manual(values = recoded_celltype_pal) +
  facet_wrap(vars(celltype_method)) +
  coord_equal() +
  theme(
    legend.position = "bottom", 
    axis.text = element_blank(), 
    axis.ticks = element_blank()
  ) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```


## Heatmap

This section shows a stacked heatmap comparing the `SingleR` and `scANVI` annotations to the consensus validation groups.

```{r, fig.height = 13, fig.width = 12} 
# make a wide version for the heatmap
celltype_wide_df <- celltype_df |>
  dplyr::select(-label) |>
  tidyr::pivot_wider(
    names_from = celltype_method,
    values_from = label_recoded
  )

list(
  "SingleR annotations" = make_jaccard_matrix(celltype_wide_df, "validation_group_annotation", "singler"),
  "scANVI annotations" = make_jaccard_matrix(celltype_wide_df, "validation_group_annotation", "scanvi")
) |>
  purrr::imap(
    \(jaccard_mat, name) create_single_heatmap(
        mat = jaccard_mat,
        row_title = name,
        column_title = "Consensus validation groups",
        keep_legend_name = "SingleR annotations" # arbitrary
    )
  ) |>
  # concatenate vertically into HeatmapList object
  purrr::reduce(ComplexHeatmap::`%v%`) |>
  ComplexHeatmap::draw(heatmap_legend_side = "right")
```


We'll also show some statistics from a confusion matrix comparison between `SingleR` and `scANVI`:

```{r}
# ensure factors are compatible for caret
all_levels <- c(
  celltype_wide_df$scanvi, 
  celltype_wide_df$singler
) |> unique()

caret::confusionMatrix(
  factor(celltype_wide_df$scanvi, levels = all_levels),  
  factor(celltype_wide_df$singler, levels = all_levels)
)$overall

```

## Cross-library comparison

Across libraries, what fraction of `SingleR` and `scANVI` labels exactly agree?
Note that this analysis does not consider similar labels (e.g. two types of T cells) but only does a quick look at identical labels.
We'll also highlight the PDX samples here to see if there was any associated bias.


```{r, fig.width = 10, fig.height = 4}
frac_agree_df <- celltype_wide_df |>
  tidyr::separate(cell_id, into = c("library_id", "barcode")) |>
  dplyr::group_by(library_id) |>
  dplyr::summarize(
    frac_agree = sum(scanvi == singler)/dplyr::n(), 
    library_size = dplyr::n()
  )
frac_agree_df <- colData(merged_sce) |> 
  as.data.frame() |> 
  dplyr::select(library_id, is_xenograft) |> 
  unique() |>
  dplyr::right_join(frac_agree_df, by = "library_id")


p1 <- ggplot(frac_agree_df) + 
  aes(x = frac_agree) + 
  geom_histogram() + 
  xlab("Fraction of SingleR and scANVI cells\nthat agree, per library")

p2 <- ggplot(frac_agree_df) + 
  aes(x = library_size, y = frac_agree, color = is_xenograft) + 
  geom_point() +
  labs(
    x = "Library size (n cells)",
    y = "Fraction of SingleR and scANVI\ncells that agree"
  ) +
  theme(legend.position = "bottom")

p1 + p2

```

## Conclusions

Overall `SingleR` and `scANVI` appear to have made highly similar predictions for the vast majority of libraries.
These cell types are also fairly similar to our existing consensus cell types.
Therefore, we can use agreement between `SingleR` and `scANVI` to derive final annotations for this analysis module.


```{r}
sessionInfo()
```
