---
title: "Explore the SingleR results"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
---

This notebooks explores the results from running cell type annotation with `SingleR` using the NBAtlas.
The NBAtlas reference was aggregated with `SingelR` prior to model training.

In this notebook, we visualize inferred cell type annotations directly, compare them to normal consensus cell types, and validate cell type assignments with marker genes.


## Setup

```{r, warning = FALSE}
options(readr.show_col_types = FALSE)
suppressPackageStartupMessages({
  library(ggplot2)
  library(patchwork)
  library(SingleCellExperiment)
})

theme_set(theme_bw())

# Define color ramp for shared use in the heatmaps
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))
# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.6, "in"))
```


### Paths

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

module_dir <- file.path(repository_base, "analyses", "cell-type-neuroblastoma-04")
ref_dir <- file.path(module_dir, "references")
results_dir <- file.path(module_dir, "results", "singler")
data_dir <- file.path(repository_base, "data", "current", "SCPCP000004")
```


```{r file paths}
# SingleR files
singler_files <- list.files(
  path = results_dir,
  pattern = "_singler-annotations\\.tsv",
  recursive = TRUE,
  full.names = TRUE
) |>
  # add names as library id
  purrr::set_names(
    \(x) {
      stringr::str_remove(basename(x), "_singler-annotations.tsv")
    }
  )

# merged SCE file
# OBTAINED FROM PORTAL DIRECTLY on 2025-07-09
sce_file <- file.path(
  data_dir,
  "SCPCP000004_merged.rds"
)

# broad consensus cell type groups
validation_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-validation-groups.tsv"

# palette file
palette_file <- file.path(
  module_dir,
  "palettes",
  "harmonized-cell-type-palette.tsv"
)

# marker genes for validation
consensus_markers_file <- file.path(ref_dir, "consensus-marker-genes.tsv")
nbatlas_markers_file <- file.path(ref_dir, "nbatlas-marker-genes.tsv")
```

### Functions

```{r}
# Source Jaccard and heatmap utilities functions
source(file.path(module_dir, "scripts", "utils", "jaccard-utils.R"))

# Source additional utilities functions:
# - harmonize_celltypes()
# - faceted_umap()
# - generate_dotplot()
source(file.path(module_dir, "scripts", "utils", "celltype-utils.R"))
```



### Prepare input data

Read SCE object to get consensus cell types and UMAP coordinates:

```{r}
merged_sce <- readRDS(sce_file)
# immediately remove assays we don't need for space
assay(merged_sce, "spliced") <- NULL
assay(merged_sce, "counts") <- NULL

# RUH ROH!!!
# https://github.com/AlexsLemonade/scpcaTools/issues/298
merged_sce$cell_id <- colnames(merged_sce)
```

Read cell type data frames:

```{r}
singler_df <- singler_files |>
  purrr::map(readr::read_tsv) |>
  purrr::list_rbind(names_to = "library_id") |>
  dplyr::select(-delta.next, -labels) |>
  dplyr::mutate(
    # add cell id column for unique rows & joining
    cell_id = glue::glue("{library_id}-{barcodes}"),
    # recode NA -> "unknown_singler"
    pruned.labels = ifelse(
      is.na(pruned.labels),
      "unknown_singler",
      pruned.labels
    )
  )

# validation data frames
validation_df <- readr::read_tsv(validation_url) |>
  dplyr::select(consensus_annotation, validation_group_annotation)
consensus_markers_df <- readr::read_tsv(consensus_markers_file)
nbatlas_markers_df <- readr::read_tsv(nbatlas_markers_file)


# set up palette for umaps
palette_df <- readr::read_tsv(palette_file)
celltype_pal <- palette_df$hex_color
names(celltype_pal) <- palette_df$harmonized_label
```

Join and prepare data for use:

```{r}
celltype_df <- scuttle::makePerCellDF(
  merged_sce,
  use.coldata = c("barcodes", "sample_id", "library_id", "consensus_celltype_annotation"),
  use.dimred = c("UMAP")
) |>
  # there are repeated barcodes so we need to keep cell_id around
  tibble::rownames_to_column("cell_id") |>
  dplyr::rename(
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2,
    consensus_annotation = consensus_celltype_annotation
  ) |>
  dplyr::left_join(validation_df, by = "consensus_annotation") |>
  # recode NAs to "unknown_consensus" and remove full consensus labels
  dplyr::mutate(validation_group_annotation = ifelse(
    is.na(validation_group_annotation),
    "unknown_consensus",
    validation_group_annotation
  )) |>
  dplyr::select(-consensus_annotation) |>
  dplyr::left_join(singler_df, by = c("cell_id", "barcodes", "library_id"))

# Recode NBAtlas cell types where possible so they match with colors
celltype_recoded_df <- celltype_df |>
  # rename to make annotation sources more clear
  dplyr::rename(
    "consensus_validation" = validation_group_annotation,
    "singler" = pruned.labels
  ) |>
  # pivot longer for wrangling
  tidyr::pivot_longer(
    c(consensus_validation, singler),
    names_to = "annotation_type",
    values_to = "label"
  ) |> 
  harmonize_celltypes(label, label_recoded) |>
  dplyr::select(-label)
```

## Heatmap

This section compares SingleR annotations to consensus cell type annotations using a heatmap.
The heatmap is colored by Jaccard similarity index.


```{r, fig.height = 10, fig.width = 10} 
# Pivot wider for heatmap functions
celltype_recoded_wide_df <- celltype_recoded_df |>
  tidyr::pivot_wider(
    names_from = annotation_type,
    values_from = label_recoded
  )

heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))

make_jaccard_heatmap(
  celltype_recoded_wide_df,
  "consensus_validation",
  "singler",
  "Consensus validation label",
  "SingleR NBAtlas label"
)
```

## UMAPs

This section visualizes and compares SingleR annotations to consensus cell type annotations using UMAPs.
Note that the displayed UMAP is from a merged object that has _not been batch-corrected._

Cell type labels have been harmonized between sources wherever possible.
Note that each set of labels has its own "stromal" category which the labels distinguish.
In addition, cells labeled `unknown_consensus` are those with no assigned consensus label, and cells labeled `unknown_singler` are those where SingleR could not confidently assign a label.

### Complete UMAP

First, we display the consensus and SingleR annotations for all cells.

```{r, fig.width = 14, fig.height = 7}
ggplot(celltype_recoded_df) +
  aes(x = UMAP1, y = UMAP2, color = label_recoded) +
  geom_point(size = 0.25, alpha = 0.5) +
  scale_color_manual(
    values = celltype_pal,
    name = "Harmonized cell types"
  ) +
  facet_wrap(vars(annotation_type)) +
  coord_equal() +
  theme(
    legend.position = "bottom",
    axis.ticks = element_blank(),
    axis.text = element_blank()
  ) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```

### SingleR annotations only

Below we display a faceted UMAP to highlight the SingleR annotations.
Light gray cells in each panel represent all other cell types.

```{r fig.width = 16, fig.height = 16}
celltype_recoded_df |>
  dplyr::filter(annotation_type == "singler") |>
  faceted_umap(
    annotation_column = label_recoded,
    celltype_colors = celltype_pal
  )
```


### Faceted comparison to consensus cell types

Below, we display faceted UMAPs highlighting a single cell type but considering only cell types that have direct correspondence between SingleR and consensus cell types.
This allows us to see if the normal cells that SingleR is labeling correspond well to the normal cells identified by consensus labels.
Each row displays a cell type where the left column shows the consensus version and the right column shows the SingleR version.

In addition, we include a category below `putative-tumor` to directly compare the unknown consensus labels with the `Neuroendocrine` cells labeled by SingleR. 
While these categories are not necessarily directly comparable, they are each most likely to contain tumor cells.

```{r, fig.width=7, fig.height=28}
direct_celltype_matches <- c(
  "B cell",
  "T cell",
  "myeloid",
  "macrophage",
  "monocyte",
  "dendritic cell",
  "natural killer cell",
  "fibroblast",
  "endothelial cell",
  "plasma cell",
  "natural killer cell",
  # we'll use this label to be able to directly compare unknown_consensus to Neuroendocrine
  "putative-tumor"
)


celltype_facet_df <- celltype_recoded_df |>
  dplyr::mutate(
    # recode so Neuroendocrine matches with unknown_consensus in the plot
    label_recoded = ifelse(
      label_recoded %in% c("Neuroendocrine", "unknown_consensus"),
      "putative-tumor",
      label_recoded
    )) |>
  dplyr::filter(label_recoded %in% direct_celltype_matches)

faceted_umap(
  celltype_facet_df,
  annotation_column = label_recoded,
  celltype_colors = celltype_pal,
  facet_type = "grid",
  annotation_type_column = annotation_type
)
```



## Marker gene expression dotplots

In this section we'll validate annotations using two sets of marker genes:

* Marker genes identified in NBAtlas corresponding to the atlas cell types
  * This will tell us if we are picking up comparable signal in our data that plays well with NBAtlas
* Consensus cell type marker genes
  * This will provide an independent assessment of the reliability of SingleR normal cell type assignments 

```{r}
# Prepare the expressed_genes vector
# we only care about if that gene is expressed otherwise we won't waste memory and include it
gene_sums <- rowData(merged_sce) |>
  as.data.frame() |>
  dplyr::select(contains("detected")) |>
  as.matrix() |>
  rowSums()
expressed_genes <- names(gene_sums)[gene_sums > 0]

# Prepare data frame with singler labels to plot
singler_recoded_df <- celltype_recoded_df |>
  dplyr::filter(
    annotation_type == "singler",
    # we don't consider the NAs here
    label_recoded != "unknown_singler"
  ) |>
  dplyr::select(cell_id, label_recoded)


# get total number of cells per final annotation group and set up y_label
total_cells_df <- singler_recoded_df |>
  dplyr::count(label_recoded, name = "total_cells") |>
  dplyr::arrange(desc(total_cells)) |>
  dplyr::mutate(y_label = glue::glue("{label_recoded} ({total_cells})"))

singler_order <- total_cells_df$y_label
total_cells_df$y_label <- factor(total_cells_df$y_label, levels = singler_order)
```



### NBAtlas marker genes

We'll show the top-seven highest logFC marker genes per cell type for validation.

```{r}
# number of marker genes to consider per validation group
n_marker_genes <- 7

nbatlas_markers_df <- nbatlas_markers_df |>
  # keep only the top `n_marker_genes`
  dplyr::filter(direction == "up") |>
  dplyr::group_by(NBAtlas_label) |>
  dplyr::mutate(rank_lfc = rank(-avg_log2FC)) |>
  dplyr::ungroup() |>
  dplyr::filter(rank_lfc <= n_marker_genes) |>
  harmonize_celltypes(NBAtlas_label, marker_gene_label) |>
  dplyr::select(marker_gene_label, gene_symbol, ensembl_gene_id)

nbatlas_bar_order <- total_cells_df$label_recoded
```


```{r, fig.width = 24, fig.height = 12}
generate_dotplot(
  merged_sce,
  nbatlas_markers_df,
  singler_recoded_df,
  total_cells_df,
  expressed_genes,
  nbatlas_bar_order
)
```



### Consensus validation marker genes


```{r}
# prepare for dotplot

consensus_markers_df <- consensus_markers_df |>
  # we'll use this to help determine the bar order
  harmonize_celltypes(NBAtlas_label, NBAtlas_label_recoded) |>
  dplyr::select(
    marker_gene_label = validation_group_annotation,
    ensembl_gene_id,
    gene_symbol,
    NBAtlas_label_recoded
  )

# get the bar order
consensus_bar_order <- total_cells_df |>
  dplyr::select(label_recoded, y_label) |>
  # inner!!!!
  dplyr::inner_join(consensus_markers_df, by = c("label_recoded" = "NBAtlas_label_recoded")) |>
  dplyr::arrange(y_label) |>
  dplyr::pull(marker_gene_label) |>
  unique()
```


```{r, fig.width = 22, fig.height = 12}
generate_dotplot(
  merged_sce,
  consensus_markers_df,
  singler_recoded_df,
  total_cells_df,
  expressed_genes,
  consensus_bar_order
)
```

```{r}
# this time we are not considering putative tumor
direct_celltype_matches <- c(
  "B cell",
  "T cell",
  # note that we need to collapse the consensus to compare
  "myeloid",
  "fibroblast",
  "endothelial cell",
  "plasma cell",
  "natural killer cell", 
  "unknown_consensus" # we do want to keep these for this analysis
)

# Define the different myeloid types in consensus annotations
consensus_myeloid <- c("myeloid", "dendritic cell", "monocyte", "macrophage")


situation_df <- celltype_recoded_df |>
  # recode labels for comparison
  dplyr::mutate(
    label_recoded = ifelse(
      label_recoded %in% consensus_myeloid,
      "myeloid",
      label_recoded
  )) |>
  dplyr::filter(label_recoded %in% direct_celltype_matches) |>
  dplyr::select(cell_id, annotation_type, label_recoded) |>
  # make it wider to label the situation
  tidyr::pivot_wider(
    names_from = "annotation_type",
    values_from = "label_recoded"
  ) |>
  # remove NAs:
  # - consensus NAs are those with other cell types not to include here
  # - singler NAs were unclassified cells
  tidyr::drop_na() |>
  dplyr::mutate(
    annotation_situation = dplyr::case_when(
      consensus_validation == "unknown_consensus" ~ "consensus not classified", 
      consensus_validation == singler ~ "matching annotations",
      consensus_validation != singler ~ "different annotations"
    )
  ) |>
  # make it long again
  tidyr::pivot_longer(
    c(consensus_validation, singler),
    names_to = "annotation_type", 
    values_to = "label_recoded"
  ) 

cells <- unique(situation_df$cell_id)
genes <- unique(consensus_markers_df$ensembl_gene_id)
```


```{r}
scuttle::makePerCellDF(
    merged_sce[genes, cells],
    features = genes,
    assay.type = "logcounts",
    use.coldata = "cell_id",
    use.dimred = FALSE
  ) |>
    tidyr::pivot_longer(starts_with("ENSG"), names_to = "ensembl_gene_id", values_to = "logcounts") |>
  dplyr::left_join(situation_df, by = "cell_id") |>
  dplyr::group_by(label_recoded, marker_gene_label, ensembl_gene_id) |>
  dplyr::summarize(
    detected_count = sum(detected),
    mean_exp = mean(logcounts)
  ) |>
  dplyr::ungroup() 


ggplot(situation_df) + 
  aes(x = singler, y = )



  group_stats_df <- all_info_df |>
    # remove genes that aren't present in final annotations
    dplyr::filter(gene_symbol %in% marker_gene_order) |>
    # for each assigned cell type/marker gene combo get total detected and mean expression
    dplyr::group_by(label_recoded, marker_gene_label, ensembl_gene_id) |>
    dplyr::summarize(
      detected_count = sum(detected),
      mean_exp = mean(logcounts)
    ) |>
    
    

```

## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
