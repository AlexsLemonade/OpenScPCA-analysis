---
title: "Explore the SingleR results"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
---


## Setup

```{r, warning = FALSE}
options(readr.show_col_types = FALSE)
suppressPackageStartupMessages({
  library(ggplot2)
  library(patchwork)
  library(SingleCellExperiment)
})

theme_set(theme_bw())

# Define color ramp for shared use in the heatmaps
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))
# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.6, "in"))
```


### Paths

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

module_dir <- file.path(repository_base, "analyses", "cell-type-neuroblastoma-04")
results_dir <- file.path(module_dir, "results", "singler")
data_dir <- file.path(repository_base, "data", "current", "SCPCP000004")
```


```{r file paths}
# SingleR files
singler_files <- list.files(
  path = results_dir,
  pattern = "_singler-annotations\\.tsv",
  recursive = TRUE,
  full.names = TRUE
) |>
  # add names as library id
  purrr::set_names(
    \(x) {
      stringr::str_remove(basename(x), "_singler-annotations.tsv")
    }
  )

# merged SCE file
# OBTAINED FROM PORTAL DIRECTLY on 2025-07-09
sce_file <- file.path(
  data_dir,
  "SCPCP000004_merged.rds"
)

# broad consensus cell type groups
validation_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-validation-groups.tsv"

# palette file
palette_file <- file.path(
  module_dir,
  "palettes",
  "harmonized-cell-type-palette.tsv"
)
```

### Functions

```{r}
# Source Jaccard and heatmap utilities functions:
source(file.path(module_dir, "scripts", "utils", "jaccard-utils.R"))
```

```{r}
harmonize_celltypes <- function(df, label_column, recoded_column) {
  df |>
    dplyr::mutate(
      {{ recoded_column }} := dplyr::case_when(
        # nbatlas ~ consensus
        {{ label_column }} %in% c("Myeloid", "Fibroblast") ~ stringr::str_to_lower({{ label_column }}),
        {{ label_column }} == "Endothelial" ~ "endothelial cell",
        {{ label_column }} == "Plasma" ~ "plasma cell",
        {{ label_column }} == "NK cell" ~ "natural killer cell",
        # make the difference stromal labels more clearly distinguishable
        {{ label_column }} == "stromal cell" ~ "stromal cell (consensus)",
        {{ label_column }} == "Stromal other" ~ "Stromal other (NBAtlas)",
        .default = {{ label_column }}
      )
    )
}
```




```{r}
# Adapted from scpca-nf
# https://github.com/AlexsLemonade/scpca-nf/blob/4bb82aa635b572a62f2028dbec587fcfd2155e26/templates/qc_report/celltypes_qc.rmd#L134-L221

#' Create a faceted UMAP panel where each panel has only one cell type colored
#'
#' @param umap_df Data frame with UMAP1 and UMAP2 columns
#' @param annotation_column Column containing broad cell type annotation
#' @param celltype_colors Named vector of colors to use for each broader validation group
#' @param facet_type Whether to use facet_wrap or facet_grid
#' @param annotation_type_column Additional column to use if facet_type is "grid"
#'
#' @return ggplot object containing a faceted UMAP where each cell type is a facet.
#'   In each panel, the cell type of interest is colored red and all other cells are grey.
faceted_umap <- function(umap_df,
                         annotation_column,
                         celltype_colors,
                         facet_type = c("wrap", "grid"),
                         annotation_type_column = NULL) {
  facet_type <- match.arg(facet_type)

  # color by the annotation column but only color one cell type at a time
  faceted_umap <- ggplot(
    umap_df,
    aes(x = UMAP1, y = UMAP2, color = {{ annotation_column }})
  ) +
    # set points for all "other" points
    geom_point(
      data = dplyr::select(
        umap_df, -{{ annotation_column }}
      ),
      color = "gray90",
      alpha = 0.5,
      size = 0.5
    ) +
    scale_color_manual(values = celltype_colors) +
    # set points for desired cell type
    geom_point(size = 0.5, alpha = 0.5) +
    coord_equal() +
    theme_bw() +
    theme(
      legend.position = "none",
      axis.ticks = element_blank(),
      axis.text = element_blank()
    )

  # add faceting as specified
  if (facet_type == "wrap") {
    faceted_umap <- faceted_umap +
      facet_wrap(
        vars({{ annotation_column }}),
        ncol = 4
      )
  } else {
    faceted_umap <- faceted_umap +
      facet_grid(
        rows = vars({{ annotation_column }}),
        cols = vars({{ annotation_type_column }})
      )
  }
  return(faceted_umap)
}
```


### Prepare input data

Read SCE object to get consensus cell types and UMAP coordinates:

```{r}
merged_sce <- readRDS(sce_file)
# immediately remove assays we don't need for space
assay(merged_sce, "spliced") <- NULL
assay(merged_sce, "counts") <- NULL
gc()

# RUH ROH!!!
# https://github.com/AlexsLemonade/scpcaTools/issues/298
merged_sce$cell_id <- colnames(merged_sce)
```

Read cell type data frames:
```{r}
singler_df <- singler_files |>
  purrr::map(readr::read_tsv) |>
  purrr::list_rbind(names_to = "library_id") |>
  dplyr::select(-delta.next, -labels) |>
  dplyr::mutate(
    # add cell id column for unique rows & joining
    cell_id = glue::glue("{library_id}-{barcodes}"),
    # recode NA -> "unknown_singler"
    pruned.labels = ifelse(
      is.na(pruned.labels),
      "unknown_singler",
      pruned.labels
    )
  )

validation_df <- readr::read_tsv(validation_url) |>
  dplyr::select(consensus_annotation, validation_group_annotation)

# set up palette for umaps
palette_df <- readr::read_tsv(palette_file)
celltype_pal <- palette_df$hex_color
names(celltype_pal) <- palette_df$harmonized_label
```

Join and prepare data for use:

```{r}
celltype_df <- scuttle::makePerCellDF(
  merged_sce,
  use.coldata = c("barcodes", "sample_id", "library_id", "consensus_celltype_annotation"),
  use.dimred = c("UMAP")
) |>
  # there are repeated barcodes so we need to keep cell_id around
  tibble::rownames_to_column("cell_id") |>
  dplyr::rename(
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2,
    consensus_annotation = consensus_celltype_annotation
  ) |>
  dplyr::left_join(validation_df, by = "consensus_annotation") |>
  # recode NAs to "unknown_consensus" and remove full consensus labels
  dplyr::mutate(validation_group_annotation = ifelse(
    is.na(validation_group_annotation),
    "unknown_consensus",
    validation_group_annotation
  )) |>
  dplyr::select(-consensus_annotation) |>
  dplyr::left_join(singler_df, by = c("cell_id", "barcodes", "library_id"))
```



```{r}
# Recode NBAtlas cell types where possible so they match with colors
celltype_recoded_df <- celltype_df |>
  # rename to make annotation sources more clear
  dplyr::rename(
    "consensus_validation" = validation_group_annotation,
    "singler" = pruned.labels
  ) |>
  # pivot longer for wrangling
  tidyr::pivot_longer(
    c(consensus_validation, singler),
    names_to = "annotation_type",
    values_to = "label"
  ) |>
  harmonize_celltypes(label, label_recoded) |>
  dplyr::select(-label)
```

```{r, fig.height = 10, fig.width = 10} 
# Pivot wider for heatmap functions
celltype_recoded_wide_df <- celltype_recoded_df |>
  tidyr::pivot_wider(
    names_from = annotation_type,
    values_from = label_recoded
  )

heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))

make_jaccard_heatmap(
  celltype_recoded_wide_df,
  "consensus_validation",
  "singler",
  "Consensus validation label",
  "SingleR NBAtlas label"
)
```


```{r, fig.width = 10}
ggplot(celltype_recoded_df) +
  aes(x = UMAP1, y = UMAP2, color = label_recoded) +
  geom_point(size = 0.25, alpha = 0.5) +
  scale_color_manual(
    values = celltype_pal,
    name = "Harmonized cell types"
  ) +
  facet_wrap(vars(annotation_type)) +
  coord_equal() +
  theme(
    legend.position = "bottom",
    axis.ticks = element_blank(),
    axis.text = element_blank()
  ) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```


Let's facet just the SingleR annotations:


```{r fig.width = 16, fig.height = 16}
celltype_recoded_df |>
  dplyr::filter(annotation_type == "singler") |>
  faceted_umap(
    annotation_column = label_recoded,
    celltype_colors = celltype_pal
  )
```


For cells that directly match up with consensus:


```{r, fig.width=8, fig.height=32}
direct_celltype_matches <- c(
  "B cell",
  "T cell",
  "myeloid",
  "fibroblast",
  "endothelial cell",
  "plasma cell",
  "natural killer cell",
  # we'll use this label to be able to directly compare unknown_consensus to Neuroendocrine
  "putative-tumor"
)


celltype_facet_df <- celltype_recoded_df |>
  # recode so Neuroendocrine matches with unknown_consensus in the plot
  dplyr::mutate(
    label_recoded = ifelse(
      label_recoded %in% c("Neuroendocrine", "unknown_consensus"),
      "putative-tumor",
      label_recoded
    )
  ) |>
  dplyr::filter(label_recoded %in% direct_celltype_matches)

faceted_umap(
  celltype_facet_df,
  annotation_column = label_recoded,
  celltype_colors = celltype_pal,
  facet_type = "grid",
  annotation_type_column = annotation_type
)
```



## Dotplot time



```{r}
# get top 7 upregulated marker genes per cell type
nbatlas_markers_df <- readr::read_tsv("../references/nbatlas-marker-genes.tsv") |>
  dplyr::filter(direction == "up") |>
  dplyr::group_by(NBAtlas_label) |>
  dplyr::mutate(rank_lfc = rank(-avg_log2FC)) |>
  dplyr::ungroup() |>
  dplyr::filter(rank_lfc <= 5) |>
  harmonize_celltypes(NBAtlas_label, label_recoded) |>
  dplyr::select(label_recoded, gene_symbol, ensembl_gene_id, avg_log2FC)
nbatlas_markers_df

all_markers
```


```{r}
# extract gene expression for marker genes from SCE
# list of all marker genes
all_markers <- nbatlas_markers_df |>
  dplyr::pull(ensembl_gene_id) |>
  unique()

# we only care about if that gene is expressed otherwise we won't waste memory and include it
gene_sums <- rowData(merged_sce) |>
  as.data.frame() |>
  dplyr::select(contains("detected")) |>
  as.matrix() |>
  rowSums()
expressed_genes <- names(gene_sums)[gene_sums > 0]


# get markers that are expressed
expressed_markers <- intersect(all_markers, expressed_genes)
expressed_markers
```


```{r}
# get logcounts from merged_sce for expressed genes
gene_exp_df <- scuttle::makePerCellDF(
  merged_sce,
  features = expressed_markers,
  assay.type = "logcounts",
  use.coldata = "cell_id",
  use.dimred = FALSE
) |>
  tidyr::pivot_longer(starts_with("ENSG"), names_to = "ensembl_gene_id", values_to = "logcounts") |>
  dplyr::mutate(detected = logcounts > 0)

# Join with cell type results and marker gene info
all_info_df <- celltype_recoded_df |>
  dplyr::filter(annotation_type == "singler") |>
  dplyr::select(cell_id, label_recoded) |>
  dplyr::left_join(gene_exp_df, by = "cell_id") |>
  # account for the same gene being present in multiple cell types
  dplyr::left_join(nbatlas_markers_df, by = c("label_recoded", "ensembl_gene_id"), relationship = "many-to-many")
```
  
  
```{r}
marker_gene_dotplot(
  all_info_df,
  markers_df = nbatlas_markers_df,
  celltype_colors = celltype_pal
)
```


CODE WORKS, NEEDS HELP THOUGH!
what I need to do when I come back to this update my names to match allys code
- broad_celltype_group is her singler
- validation_group_annotation is her nbatlas marker gene df label

Then i can use the same code to make a consensus dotplot.

```{r}
min_cells <- 0
# prep for plots
# get total number of cells per final annotation group
total_cells_df <- all_info_df |>
  dplyr::select(cell_id, label_recoded) |>
  dplyr::distinct() |>
  dplyr::count(label_recoded, name = "total_cells")

# table with one row per unique broad cell type/ marker gene combination
# first all cells in with the same broad_celltype_group (determined based on consensus_annotation) are grouped together
# then get the mean gene expression and total percentage of cells that express each marker gene across all cells in that group
# do this for every possible marker gene/ validation group assignment
# second we calculate the mean expression and mean percentage of all marker genes in a given validation group (this value is used only in the second section of the report)
group_stats_df <- all_info_df |>
  # for each assigned cell type/marker gene combo get total detected and mean expression
  # group by both broad group and validation group to account for genes that are expressed in more than one cell type
  dplyr::summarize(
    .by = c("label_recoded", "ensembl_gene_id"),
    detected_count = sum(detected),
    mean_exp = mean(logcounts)
  ) |>
  # add in validation group for marker genes
  # this includes all possible marker genes and all possible validation group assignments
  dplyr::left_join(nbatlas_markers_df, by = c("ensembl_gene_id", "label_recoded"), relationship = "many-to-many") |> # add total cells
  dplyr::left_join(total_cells_df, by = c("label_recoded")) |>
  # only show cells that have above the minimum total number
  dplyr::filter(total_cells > min_cells) |>
  dplyr::mutate(
    # get total percent expressed
    percent_exp = (detected_count / total_cells) * 100,
    # account for NA/unknowns and set axes order
    broad_celltype_group = factor(label_recoded, levels = c(names(celltype_pal)))
  )


# specify x axis order for dotplot
marker_gene_order <- nbatlas_markers_df |>
  dplyr::pull(gene_symbol) |>
  unique()

# set order for cell types
celltype_order <- unique(nbatlas_markers_df$label_recoded)

# filter out low expressed genes
dotplot_df <- group_stats_df |>
  dplyr::filter(mean_exp > 0, percent_exp > 10) |>
  dplyr::arrange(label_recoded) |>
  # add a label for the plot
  dplyr::mutate(y_label = glue::glue("{label_recoded} ({total_cells})")) |>
  # remove marker genes that aren't present in final annotations and set x axis order
  dplyr::filter(gene_symbol %in% marker_gene_order) |>
  dplyr::mutate(
    # set orders of gene symbol and validation groups
    y_label = factor(y_label, levels = rev(unique(y_label))),
    gene_symbol = factor(gene_symbol, levels = marker_gene_order),
    label_recoded = factor(label_recoded, levels = celltype_order)
  )


# make dotplot with marker gene exp
dotplot <- ggplot(dotplot_df, aes(y = y_label, x = gene_symbol, color = mean_exp, size = percent_exp)) +
  geom_point() +
  scale_color_viridis_c(option = "magma") +
  facet_grid(cols = vars(label_recoded), scales = "free", space = "free") +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "transparent", color = NA),
    strip.placement = "outside",
    strip.text.x = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.ticks.x = element_blank(),
    text = element_text(size = 14),
    panel.spacing = unit(0.5, "lines") # adjust spacing and match with annotation bar
  ) +
  labs(
    x = "",
    y = "label_recoded",
    color = "Mean gene expression",
    size = "Percent cells expressed"
  )


# add annotation bar aligning marker genes with validation group
color_bar <- ggplot(dotplot_df, aes(x = gene_symbol, y = 1, fill = label_recoded)) +
  geom_tile() +
  facet_grid(cols = vars(label_recoded), scales = "free", space = "free") +
  scale_fill_manual(values = celltype_pal, breaks = levels(dotplot_df$label_recoded)) +
  ggmap::theme_nothing() +
  theme(
    strip.background = element_rect(fill = "transparent", color = NA),
    strip.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5, size = 12),
    strip.placement = "outside",
    legend.position = "none",
    panel.spacing = unit(0.5, "lines"),
    strip.clip = "off"
  ) +
  labs(fill = "")

combined_plot <- color_bar / dotplot +
  patchwork::plot_layout(ncol = 1, heights = c(0.1, 4))
```


```{r fig.width = 20}
combined_plot
```





## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
