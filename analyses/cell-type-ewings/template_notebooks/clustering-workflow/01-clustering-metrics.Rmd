---
title: "Clustering exploration for `r params$library_id`"
author: Ally Hawkins
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: "hide"
params:
  library_id: "SCPCL000822"
  sce_file: "../../../../data/current/SCPCP000015/SCPCS000490/SCPCL000822_processed.rds"
  cluster_results_file: "SCPCL000822_clusters.tsv"
---

This notebook summarizes clustering metrics for `r params$library_id`.

Louvain clusters are calculated using the following range of parameters: 

- Nearest neighbors: 5, 10, 15, 20, 25, 30, 35, and 40
- Resolution: 0.5, 1, 1.5

Leiden clusters are calcualted using the following range of parameters: 

- Objective function: CPM and modularity 
- Nearest neighbors: 5, 10, 15, 20, 25, 30, 35, and 40
- Resolution: 0.5, 1, 1.5

- Metrics are then calculated to evaluate clustering results across all parameters: 
  - Silhouette width 
  - Cluster purity 
  - Cluster stability 

## Setup

```{r}
# check that sce file exists
stopifnot(
  "sce file does not exist" = file.exists(params$sce_file)
)
```


```{r packages}
suppressPackageStartupMessages({
  # load required packages
  library(SingleCellExperiment)
  library(ggplot2)
})

# Set default ggplot theme
theme_set(
  theme_classic()
)

# set seed
set.seed(2024)
```


```{r base paths}
# The path to this module
module_base <- rprojroot::find_root(rprojroot::is_renv_project)

# source in clustering functions
clustering_functions <- file.path(module_base, "scripts", "utils", "clustering-functions.R")
source(clustering_functions)
```


```{r}
# read in input sce files
sce <- readr::read_rds(params$sce_file)
```


## Calculate clusters


```{r}
# louvain clustering across all parameters 
louvain_results <- rOpenScPCA::sweep_clusters(
  sce,
  algorithm = "louvain",
  nn = seq(5, 40, 5),
  resolution = c(0.5, 1, 1.5)
) |> 
  dplyr::bind_rows() |> 
  # add in objective function so we can combine with leiden results
  dplyr::mutate(objective_function = NA_character_)

# leiden clustering
leiden_results <- rOpenScPCA::sweep_clusters(
  sce,
  algorithm = "leiden",
  nn = seq(5, 40, 5),
  resolution = c(0.5, 1, 1.5),
  objective_function = c("CPM", "modularity")
) |> 
  dplyr::bind_rows()
```


```{r}
# join all clustering results 
all_cluster_results <- dplyr::bind_rows(list(louvain_results, leiden_results)) |> 
  # add column for method + objective function 
  # use this for splitting plots throughout report
  dplyr::mutate(cluster_method = glue::glue(
    "{algorithm}-{objective_function}"
  ) |> 
    stringr::str_remove("-NA")
  )
```


## Visualize clusters with UMAP

```{r}
# get umap embeddings and combine into a data frame with cluster assignments
umap_df <- sce |>
  scuttle::makePerCellDF(use.dimred = "UMAP") |>
  # replace UMAP.1 with UMAP1 and get rid of excess columns
  dplyr::select("cell_id" = barcodes, UMAP1 = UMAP.1, UMAP2 = UMAP.2) |>
  dplyr::left_join(all_cluster_results, by = "cell_id")

split_umap_df <- umap_df |> 
  # add a column that shows the combination of nn/res so we get stats for each unique combo of params 
  dplyr::mutate(cluster_params = glue::glue("{nn}nn-{resolution}res")) |> 
  split(umap_df$cluster_method)
```


Below we visualize the cluster assignments using each parameter on a UMAP. 
This can be helpful to see if any parameters lead to any obvious over or under clustering. 

```{r, fig.height=15, fig.width=10}
# look at clustering results for each library across all params
split_umap_df |> 
  purrr::imap(\(df, method){
    
    ggplot(df, aes(x = UMAP1, y = UMAP2, color = cluster)) +
      geom_point(alpha = 0.5, size = 0.1) +
      facet_grid(rows = vars(nn),
                 cols = vars(resolution),
                 labeller = labeller(nn = ~ glue::glue("{.}-nn"),
                                     resolution = ~ glue::glue("{.}-res"))) +
      theme(
        aspect.ratio = 1,
        legend.position = "none"
      ) +
      labs(title = method)
    
  })
```


## Clustering statistics 

Below we calculate a series of statistics: 

- Average silhouette width: This metric evaluates cluster separation. 
Cells with large positive silhouette widths are closer to other cells in the same cluster than to cells in different clusters. 
Higher values indicate tighter clusters.
- Average cluster purity: This metric also evaluates cluster separation and tells us the proportion of neighboring cells that are assigned to the same cluster. 
Purity values range from 0-1 with higher purity values indicating clusters that are well separated. 
- Cluster stability: This evaluates how stable the clustering is to input data. 
Stability values range from 01- with higher values of cluster stability indicating more reproducible clusters. 

```{r, warning=FALSE}
# get a combined stats dataframe with purity and width for all clusters
all_stats <- split_umap_df |> 
  purrr::map(\(df) {get_cluster_stats(sce,df)})
```

### Silhouette width

```{r}
# silhouette width for different params
all_stats |> 
  purrr::imap(\(df, cluster_method){plot_cluster_stats(df, width, cluster_method)})
```

### Cluster purity 

```{r}
# cluster purity for different params
all_stats |> 
  purrr::imap(\(df, cluster_method){plot_cluster_stats(df, purity, cluster_method)})
```

### Cluster stability 

```{r, warning=FALSE, message=FALSE}
# calculate cluster stability
stability_stats <- split_umap_df |> 
  purrr::map(\(df){ get_cluster_stability(sce, df)})
```


```{r, warning=FALSE, message=FALSE}
# plot stability across all parameters
stability_stats |> 
  purrr::imap(\(df, cluster_method){
    
    
    # plot stability across all values of k
    ggplot(df, aes(x = nn, y = ari)) +
      geom_jitter(width = 0.1) +
      facet_wrap(vars(resolution),
                 labeller = labeller(resolution = ~ glue::glue("{.}-res"))) +
      labs(title = "Cluster stability") +
      stat_summary(
        aes(group = nn),
        color = "red",
        # median and quartiles for point range
        fun = "median",
        fun.min = function(x) {
          quantile(x, 0.25)
        },
        fun.max = function(x) {
          quantile(x, 0.75)
        }
      )
    
    
  })
```

## Export clusters 

```{r}
# export all clustering results
readr::write_tsv(all_cluster_results, params$cluster_results_file)
```


## Session info 

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```


