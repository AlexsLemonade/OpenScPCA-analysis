---
title: "Explore tumor cell classification with marker genes and CellAssign - SCPCS000490"
author: Ally Hawkins
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
params:
  sample_id: SCPCS000490
  library_id: SCPCL000822
---


## Introduction

This notebook looks at expression of marker genes for tumor cells in a Ewing sarcoma sample, `r {params$sample_id}`. 
Additionally, we see if we can use those marker genes to classify tumor and normal cells using both manual annotation and `CellAssign`. 

The first section focuses on assigning tumor and normal cells by looking at marker gene expression alone: 

- First we look at expression of each of the marker genes across all cells. 
- Then we plot the mean expression of all marker genes across all cells. 
- Next, we perform clustering and see if we can assign each cluster as tumor or normal cells based on mean expression of marker genes. 

The next section uses `CellAssign` to assign tumor cells with the same set of marker genes: 

- We use `CellAssign` with both the full list of marker genes and filtered list of marker genes. 
- We then compare the average gene expression of all marker genes between tumor and other cells. 

## Setup

```{r packages}
suppressMessages(
  # load required packages
  library(SingleCellExperiment),
  library(ggplot2)
)
```


```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The current data directory, found within the repository base directory
data_dir <- file.path(repository_base, "data", "current")
sample_dir <- file.path(data_dir, "SCPCP000015", params$sample_id)

# The path to this module
module_base <- file.path(repository_base, "analyses", "ewings-cell-type")
```


```{r paths}
# Input files
sce_filename <- glue::glue("{params$library_id}_processed.rds")
sce_file <- file.path(sample_dir, sce_filename)

anndata_filename <- glue::glue("{params$library_id}_processed_rna.hdf5")
anndata_file <- file.path(sample_dir, anndata_filename)

marker_genes <- file.path(module_base, "references", "tumor_marker_genes.tsv")

# Output files
tumor_markers_mtx_file <- file.path(module_base, "references", "cellassign_refs", "tumor-marker-cellassign.tsv")
filtered_markers_mtx_file <- file.path(module_base, "references", "cellassign_refs", "filtered-tumor-marker-cellassign.tsv")
cellassign_predictions_file <- file.path(module_base, "results", "cellassign-tumor-predictions.tsv")
filtered_predictions_file <- file.path(module_base, "results", "filtered-cellassign-tumor-predictions.tsv")
```

```{r}
# read in processed sce
sce <- readr::read_rds(sce_file)

# read in marker genes table 
marker_genes_df <- readr::read_tsv(marker_genes) |> 
  # account for genes being from multiple sources
  dplyr::select(cell_type, ensembl_gene_id, gene_symbol) |> 
  dplyr::distinct()

marker_genes <- marker_genes_df |> 
  dplyr::filter(cell_type == "tumor") |> 
  dplyr::pull(ensembl_gene_id)
```


## Analysis content

### Explore marker gene expression 

The first thing we do here is just create a faceted UMAP showing the expression of each marker gene for tumor cells. 

```{r}
# get the gene expression counts for all marker genes
marker_gene_exp <- logcounts(sce[marker_genes, ]) |>
    as.matrix() |>
    t() |>
    as.data.frame() |>
    tibble::rownames_to_column("barcodes")

# pull out the UMAP coordinates and make a data frame to use for plotting
umap_df <- sce |> 
  scuttle::makePerCellDF(use.dimred = "UMAP") |> 
  # replace UMAP.1 with UMAP1
  dplyr::rename_with(
        \(x) stringr::str_replace(x, "^UMAP\\.", "UMAP"),
        starts_with("UMAP")
      ) |> 
  # add in marker gene expression to dataframe 
  dplyr::left_join(marker_gene_exp, by = "barcodes") |> 
  # combine all genes into a single column for easy faceting
  tidyr::pivot_longer(
    cols = starts_with("ENSG"),
    names_to = "ensembl_gene_id",
    values_to = "gene_expression"
  ) |> 
  # join with marker gene df to get gene symbols for plotting 
  dplyr::left_join(marker_genes_df, by = c("ensembl_gene_id")) |>
  dplyr::select(barcodes, UMAP1, UMAP2, gene_symbol, ensembl_gene_id, gene_expression, clusters)
```


```{r}
# faceted umap showing a umap panel for each marker gene 
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = gene_expression)) +
    geom_point(alpha = 0.1, size = 0.2) +
    facet_wrap(vars(gene_symbol)) +
    scale_color_viridis_c() +
    labs(
      color = "Log-normalized gene expression"
    ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    theme(
      aspect.ratio = 1,
      legend.position = "bottom",
      axis.title = element_text(size = 9, color = "black"),
      strip.text = element_text(size = 8),
      legend.title = element_text(size = 9),
      legend.text = element_text(size = 8)
    ) +
    guides(colour = guide_colorbar(title.position = "bottom", title.hjust = 0.5)) +
  theme_bw()
```

Looking at this plot, there is definitely some variation in the expression of marker genes. 
It looks like the highest gene expression is seen in the larger group of cells on the bottom right of the UMAP. 

Below, we can get the mean gene expression of all marker genes and plot in a single UMAP. 

```{r}
# calculate mean gene expression across all marker genes in list 
marker_mean_exp <- umap_df |> 
  dplyr::group_by(barcodes) |> 
  dplyr::mutate(mean_exp = mean(gene_expression)) |> 
  dplyr::select(barcodes, UMAP1, UMAP2, mean_exp, clusters) |> 
  dplyr::distinct()

# plot mean gene expression 
ggplot(marker_mean_exp, aes(x = UMAP1, y = UMAP2, color = mean_exp)) +
  geom_point(size = 0.5, alpha = 0.5) +
  scale_color_viridis_c() +
  theme_bw()
```

Similar to the individual plots, it looks like there is one group of cells on the bottom right that has the highest mean gene expression. 
We would anticipate that these are most likely to be the tumor cells. 

### Using clusters and marker gene expression to annotate tumor cells

We anticipate that the tumor cells and normal cells would cluster separately. 
First, let's just plot the cluster assignments alone.  

```{r}
ggplot(marker_mean_exp, aes(x = UMAP1, y = UMAP2, color = clusters)) +
  geom_point(size = 0.5, alpha = 0.5) +
  theme_bw()
```

It looks like our large group of cells on the bottom right is comprised of a few clusters while most other groups of cells are a single cluster. 
Let's see if there's any difference in mean expression of the marker genes across the clusters. 
Based on the gene expression I would expect most cells in the bottom right to be considered tumor and all other cells to be normal. 

```{r}
# plot marker gene expression across all clusters 
ggplot(marker_mean_exp, aes(x = mean_exp, fill = clusters)) +
  geom_density() +
  facet_grid(rows = vars(clusters)) +
  theme_bw()
```

Looking at this there are definitely distinct groups of cells with higher mean expression of the marker genes than other cells. 
Before doing anything fancy, let's use this to manually assign tumor and normal cells. 
One approach is to assign based on the cluster, so if the cluster has a median expression > 0.75 then all cells in that cluster would get assigned as tumor cells. 
We could also pick a mean expression cutoff and use that to assign each cell individually, but there are some tails that overlap. 

```{r}
# classify clusters as tumor/normal 
cluster_classification_df <- marker_mean_exp |> 
  dplyr::group_by(clusters) |> 
  # calculate the median mean gene expression across all cells in a cluster
  dplyr::summarise(median_cluster_exp = median(mean_exp)) |> 
  # use 0.75 as the cutoff for tumor/normal 
  dplyr::mutate(tumor_normal_classification = dplyr::if_else(median_cluster_exp > 0.75, "Tumor", "Normal"))

# get individual cell classifications
celltype_classification_df <- marker_mean_exp |> 
  dplyr::left_join(cluster_classification_df)

# umap showing tumor and normal cells 
ggplot(celltype_classification_df, aes(x = UMAP1, y = UMAP2, color = tumor_normal_classification)) +
  geom_point(size = 0.5, alpha = 0.5) +
  theme_bw()
```

### Run CellAssign with marker genes 

Now let's see if we can use an automated marker gene-based method to identify tumor cells. 
To do this we will use `CellAssign` with a reference matrix created from the marker gene list. 

First, we need to create a binary matrix with two columns, "tumor" and "other". 
The "other" will refer to any normal cells. 

```{r}
binary_mtx <- marker_genes_df |>
  dplyr::select(cell_type, ensembl_gene_id) |> 
  unique() |> 
  tidyr::pivot_wider(
    id_cols = ensembl_gene_id,
    names_from = cell_type,
    values_from = cell_type,
    values_fn = length,
    values_fill = 0
  ) |>
  # add a column with no marker genes
  # cell assign will assign cells to "other" when no other cell types are appropriate
  dplyr::mutate(other = 0)

# export matrix 
readr::write_tsv(binary_mtx, tumor_markers_mtx_file)
```

Now run `CellAssign` with the full marker gene list as the reference. 

```{r, eval=FALSE}
cellassign_call <- glue::glue("
python scripts/run-cellassign.py \
  --anndata_file '{anndata_file}' \
  --output_predictions '{cellassign_predictions_file}' \
  --reference '{tumor_markers_mtx_file}'
")

system(cellassign_call)
```


We can then read in the predictions file and find the predicted cell type for each cell, either "tumor" or "other". 

```{r}
# read in predictions
predictions <- readr::read_tsv(cellassign_predictions_file)

# get individual cell type assignments
# those with the max prediction 
celltype_assignments <- predictions |>
      tidyr::pivot_longer(
        !barcode,
        names_to = "celltype",
        values_to = "prediction"
      ) |>
      dplyr::group_by(barcode) |>
      dplyr::slice_max(prediction, n = 1) |>
      dplyr::ungroup()
# create a table of assignments 
table(celltype_assignments$celltype)
```

Looking at this, it appears that `CellAssign` is classifying all cells as "other"? 
I find this hard to believe since this sample was taken directly from a Ewing sarcoma tumor, so there are bound to be tumor cells. 

In looking at the original UMAP there are quite a few genes that have very low expression across all cells, so perhaps they are adding noise to the model. 
Although this is a bit circular, we could restrict our list of marker genes to be only those that have a high mean gene expression in our dataset? 
I would expect that when we do that, we are able to identify more tumor cells that line up with what we would expect based on gene expression patterns. 

```{r}
# grab the mean gene expression for all marker genes 
rowdata_df <- rowData(sce) |> 
  as.data.frame() |> 
  dplyr::filter(gene_symbol %in% marker_genes_df$gene_symbol)
rowdata_df
```

```{r}
# what's the mean gene expression of all genes in this sample for reference
mean(rowData(sce)$mean)
```


There are a few genes that have low gene expression < 1. 
Let's try and filter out those genes and then use `CellAssign`. 

```{r}
# get list of marker genes to keep
filtered_markers <- rowdata_df |> 
  dplyr::filter(mean > 1) |> 
  dplyr::pull(gene_ids)

# filter binary mtx 
filtered_binary_mtx <- binary_mtx |> 
  dplyr::filter(ensembl_gene_id %in% filtered_markers)

readr::write_tsv(filtered_binary_mtx, filtered_markers_mtx_file)
```


```{r, eval=FALSE}
cellassign_call <- glue::glue("
python scripts/run-cellassign.py --anndata_file '{anndata_file}' --output_predictions '{filtered_predictions_file}' --reference '{filtered_markers_mtx_file}'
")

system(cellassign_call)
```


Now we can read in the predictions for the filtered marker gene list. 

```{r}
predictions <- readr::read_tsv(filtered_predictions_file)

celltype_assignments <- predictions |>
      tidyr::pivot_longer(
        !barcode,
        names_to = "celltype",
        values_to = "prediction"
      ) |>
      dplyr::group_by(barcode) |>
      dplyr::slice_max(prediction, n = 1) |>
      dplyr::ungroup()

table(celltype_assignments$celltype)
```

Now we are seeing a few more tumor cells, let's see where they are? 

```{r}
celltype_df <- marker_mean_exp |> 
  dplyr::left_join(celltype_assignments, by = c("barcodes" = "barcode"))

ggplot(celltype_df, aes(x = UMAP1, UMAP2, color = celltype)) +
  geom_point(size = 0.5, alpha = 0.5) + 
  theme_bw()
```

Not quite where I would expect to see tumor cells. 
Let's look at the mean expression of marker genes between tumor and other cells as classified by `CellAssign`. 

```{r}
ggplot(celltype_df, aes(x = mean_exp, fill = celltype)) +
  geom_density() +
  facet_grid(rows = vars(celltype)) +
  theme_bw()
```

Unlike what I would expect, the "other" cells appear to have higher expression of marker genes? 
Maybe using `CellAssign` with only two options and a small set of marker genes doesn't work in the way we would expect. 

## Conclusions 

- We do see variation in marker gene expression, with a large group of cells expressing multiple marker genes at a higher level than all other cells. 
- This same group of cells has the highest mean gene expression of all marker genes. 
- We see a clear separation in marker gene expression between clusters. 
- Assigning tumor cells by cluster identifies a distinct group of tumor cells. 
- Using `CellAssign` with the same list of marker genes doesn't identify any tumor cells. 
- Using `CellAssign` with a restricted list of marker genes identfies tumor cells that have lower marker gene expression than other cells. 
This is opposite of the assignment we obtained using manual annotation. 

## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
