---
title: "Performing and evaluating graph-based clustering with rOpenScPCA"
date: "`r Sys.Date()`"
author: Data Lab
params:
  seed: 2024
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    df_print: paged
---


## Introduction

This notebook provides examples of how to use the `rOpenScPCA` package to:

- Perform clustering on an SCE or Seurat object
- Evaluate clustering results using several metrics including:
  - Silhouette width
  - Neighborhood purity
  - Cluster stability, as measured with the Adjusted Rand index
- Save clustering results to an SCE or Seurat object

To demonstrate these tasks, this notebook will use the sample `SCPCS000001` from project `SCPCP000001`, which is assumed present in the `OpenScPCA-analysis/data/current/SCPCP000001` directory.
Please [see this documentation](https://openscpca.readthedocs.io/en/latest/getting-started/accessing-resources/getting-access-to-data/) for more information about obtaining ScPCA data.

## Setup

### Packages


```{r packages}
library(rOpenScPCA)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(Seurat)
  library(dplyr)
  library(ggplot2)
})

# Set ggplot theme
theme_set(theme_bw())
```

### Paths

```{r base paths}
# The base path for the OpenScPCA repository
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The current data directory, found within the repository base directory
data_dir <- file.path(repository_base, "data", "current")

# The path to this module
module_base <- file.path(repository_base, "analyses", "hello-clusters")
```

### Input and output files


```{r paths}
# Path to processed SCE file for sample SCPCS000001
input_sce_file <- file.path(data_dir, "SCPCP000001", "SCPCS000001", "SCPCL000001_processed.rds")
```


### Read in data

To begin, we'll read in the `SingleCellExperiment` (SCE) object and convert it to a Seurat object.
This will allow us to demonstrate `rOpenScPCA` usage with both SCE and Seurat objects.

```{r read data}
# Read the SCE file
sce <- readRDS(input_sce_file)

# Convert to a Seurat object for demonstration
seurat_obj <- as.Seurat(
  sce,
  counts = "counts",
  data = "logcounts"
)
```

## Perform clustering

This section will show how to perform clustering with the function `rOpenScPCA::calculate_clusters`. 

By default, this function will calculate clusters using the following parameters:

* Louvain algorithm
* Jaccard weighting
* 10 nearest neighbors
* A resolution parameter of 1

These parameters can be customized, as follows:

* The `algorithm` can be one of:
  * `"louvain"`, `"walktrap"`, or `"leiden"`
* The `weighting` can be one of:
  * `"jaccard"`, `"rank"`, or `"number"`
* The nearest neighbors parameter can be customized with the `nn` argument
* The resolution parameter can be customized with the `resolution` argument
  * This parameter is only used by Louvain and Leiden algorithms
* If the Leiden algorithm is used, its default objective function parameter will be `"CPM"`, but you can also set  `objective_function = "modularity"` instead.
* You can provide additional parameters as a list to the `cluster_args` argument.
  * Please refer to the [`igraph` documentation](https://igraph.org/r/html/latest) to learn more about what additional parameters can be provided to each clustering algorithm.
  * Note that `cluster_args` only accepts single-length arguments (no vectors or lists).


This function will return a table with the following columns:

* `cell_id`: Unique cell identifiers, e.g. cell barcodes
* `cluster`: A factor column with the cluster identities
* There will be one column for each clustering parameter used


### Clustering on an SCE object

When performing clustering on an SCE object, `rOpenScPCA::calculate_clusters` assumes that the principal components are stored in a reduced dimension slot named `"PCA"`.
If your 
The function assumes the PC name is `"PCA"`. 
If your SCE has a different name for the principal components, you can provide the name with the argument `pc_name`.

We also strongly recommend providing a random seed with the `seed` argument to ensure reproducibility.

```{r cluster sce}
# Calculate clusters with default parameters
cluster_results <- calculate_clusters(
  sce,
  seed = params$seed
)

# Print resulting table
cluster_results
```

The following chunk shows an example of performing clustering with several non-default parameters:

```{r cluster sce nondefault}
# Calculate clusters with non-default parameters
cluster_results <- calculate_clusters(
  sce,
  algorithm = "leiden",
  nn = 15,
  objective_function = "modularity",
  seed = params$seed
)

# Print resulting table
cluster_results
```



### Clustering on a Seurat object

When performing clustering on a Seurat object, `rOpenScPCA::calculate_clusters` assumes that the principal components are stored in a reduced dimension slot named `"pca"`.
If your Seurat has a different name for the principal components, you can provide the name with the argument `pc_name`.
In this example, because we created the Seurat object from the SCE object, its principal components are named `"PCA"`, so we will provide that information.

We also strongly recommend providing a random seed with the `seed` argument to ensure reproducibility.

```{r cluster seurat}
cluster_results <- calculate_clusters(
  seurat_obj,
  # Since we converted this from an SCE object, its PC name is `"PCA"`
  pc_name = "PCA",
  seed = params$seed
)


cluster_results
```


## Evaluate clustering results

This section demonstrates how to use several functions for evaluating cluster quality and reliability. 
All examples will use the SCE object for demonstration, but a Seurat object can be provided instead.

All functions presented in this section take the following required arguments:

* An SCE or Seurat object that contains principal components
  * If the PCA matrix name is not the default for the object type (`"PCA"` for SCE and `"pca"` for Seurat), you can use `pc_name` to specify its name.
* A data frame with, at least, columns representing unique cell ids and cluster assignments.
  * By default, these columns should be named `cell_id` and `cluster`, respectively, matching the output of `rOpenScPCA::calculate_clusters`
  * You can override these defaults using the arguments `cell_id_col` and `cluster_col`



### Silhouette width

Silhouette width is a common metric that measures how well separated clusters are by, for each cell, comparing the average distance to all cells in the same cluster, and all cells in other clusters.
This value ranges from -1 to 1.
Cells in well-separated clusters should have high silhouette values closer to 1.
You can read more about silhouette width purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#silhouette-width).

We'll use the function `rOpenScPCA::calculate_silhouette` to calculate the silhouette width, and then we'll visualize the results.

This function will return the inputted data frame with two additional columns:

* `silhouette_width`: The calculated silhouette width for the cell
* `silhouette_other`: The closet cluster to the cell besides the cluster to which it belongs, as used in the silhouette width calculation


```{r silhouette}
silhouette_results <- calculate_silhouette(
  sce,
  cluster_results
)

silhouette_results
```



```{r plot silhouette density}
# Calculate mean silhouette width
mean_silhouette_width <- mean(silhouette_results$silhouette_width)

# Visualize values as a density plot, showing the mean value as a vertical line
ggplot(silhouette_results) +
  aes(x = silhouette_width) +
  geom_density(fill = "lightblue") +
  geom_vline(xintercept = mean_silhouette_width, color = "red", linewidth = 1)
```

Looking at the full distribution of silhouette width values, we see most are positive which is encouraging, but the values are mostly below 0.5, and the mean is less than 0.25.
Silhouette width therefore suggests that, while these clusters do have some structure, they are not very tight.

We can also explore the silhouette width results on a per-cluster basis:

```{r plot silhouette violin}
ggplot(silhouette_results) +
  aes(x = cluster, y = silhouette_width) +
  geom_violin() +
  geom_jitter(size = 0.75, alpha = 0.25) +
  # show the mean +/- SE in red
  stat_summary(color = "red")
```

This visualization shows us that cluster 5 in particular has the lowest silhouette width values, and clusters 11 and 12 have the highest.



### Neighborhood purity

Neighborhood purity is defined, for each cell, as the proportion of neighboring cells that are assigned to the same cluster.
This value ranges from 0 to 1.
Cells in well-separated clusters should have high purity values closer to 1, since there should be minimal overlap between member and neighboring cells.
You can read more about neighborhood purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#cluster-purity).

We'll use the function `rOpenScPCA::calculate_purity` to calculate the neighborhood purity, and then visualize the results.

This function will return the inputted data frame with two additional columns:

* `purity`: The neighborhood purity for the cell
* `maximum_neighbor`: The cluster with the highest proportion of observations neighboring the cell


```{r purity}
purity_results <- calculate_purity(
  sce,
  cluster_results
)

purity_results
```

```{r plot purity density}
mean_purity <- mean(purity_results$purity)

# Visualize values as a density plot, showing the mean value as a vertical line
ggplot(purity_results) +
  aes(x = purity) +
  geom_density(fill = "lightblue") +
  geom_vline(xintercept = mean_purity, color = "red", linewidth = 1)
```
This metric shows a relatively high average neighborhood purity, suggesting that neighboring cells tend to belong to the same cluster.

We can again visualize this on a per-cluster basis:

```{r plot purity violin}
ggplot(purity_results) +
  aes(x = cluster, y = purity) +
  geom_violin() +
  geom_jitter(size = 0.75, alpha = 0.25) +
  # show the mean in value
  stat_summary(color = "red")
```

In this view, we see that clusters 1, 3, and 6 all have average values below 0.75, but the rest are higher, in particular clusters 11, 12, and 13.
It's worth noting that both silhouette width and neighborhood purity found that clusters 11 and 12 were among the tightest clusters.


### Cluster stability

Another approach to exploring cluster quality is how stable the clusters themselves are using bootstrapping. 
Given a set of original clusters, we can compare the bootstrapped cluster identities to original ones using the Adjusted Rand Index (ARI), which measures the similarity of two data clusterings.
ARI ranges from -1 to 1, where:

* A value of 1 indicates they are completely overlapping
* A value of -1 indicates they are completely distinct
* A value of 0 indicates a random relationship

We expect that highly stable clusterings have ARI values closer to 1 across a set of bootstrap replicates.

You can read more about the Adjusted Rand Index from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/release/OSCA.advanced/clustering-redux.html#adjusted-rand-index).

We'll use the function `rOpenScPCA::calculate_stability` to calculate the stability of clusters using a bootstrapping approach, and then visualize the results.
By default, this function performs 20 bootstrap replicates, but this can be customized using the argument `replicates`.

This function will return a data frame with columns `replicate`, `ari`, and additional columns for the clustering parameters used when calculating bootstrap clusters.

Since this function uses random sampling when performing bootstrapping, it's also important to pass in a random seed for reproducibility with the argument `seed`.

```{r stability, warning=FALSE}
stability_results <- calculate_stability(
  sce,
  cluster_results,
  seed = params$seed
)

stability_results
```


We can visualize these results, for example, with a density plot with a rug to emphasize individual values:

```{r plot stability}
ggplot(stability_results) +
  aes(x = ari) +
  geom_density(fill = "lightblue") +
  geom_rug(color = "red", linewidth = 1)
```

All bootstrap replicates produced values around 0.7, which is relatively high and close to 1, which suggests that the these clusters are stable and robust to starting conditions.

#### Using non-default clustering parameters

When calculating bootstrap clusters, `rOpenScPCA::calculate_stability` uses `rOpenScPCA::calculate_clusters` with default parameters. 
If your original clusters were not calculated with these defaults, you should pass those customized values into this function as well to ensure a fair comparison between your original clusters and the bootstrap clusters.


```{r stability custom parameters, warning=FALSE}
# Calculate clusters with non-default parameters
cluster_df_leiden <- calculate_clusters(
  sce,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15,
  seed = params$seed
)

# Now, pass in the same arguments customizing parameters here
stability_results_leiden <- calculate_stability(
  sce,
  cluster_df_leiden,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15,
  seed = params$seed
)

stability_results_leiden
```


## Saving clustering results 

Results can either be directly exported as a TSV file (e.g., with `readr::write_tsv`), or you can add the results into your scRNA-seq object.
The subsequent examples will show you, as an example, how to save the `cluster_results` data frame to a given object.


_A word of caution!_
Objects from the ScPCA Portal already contain a column called `cluster` with results from an automated clustering.
These automatic clusters were not evaluated, and their parameters were not optimized for any given library.

To avoid ambiguity between the existing and new clustering results, you may want to rename incoming columns.
We'll therefore begin by adding the prefix `ropenscpca_` to all column names in the `cluster_results` data frame before adding them to a given object.

```{r rename columns}
# First, rename columns in `cluster_results` to avoid ambiguity
cluster_results_renamed <- cluster_results |>
  # add the prefix openscpca_ to all columns
  dplyr::rename_with(~ paste0("ropenscpca_", .x))

cluster_results_renamed
```


### Saving results to an SCE object 

Follow these steps to save the clustering results to an SCE object's `colData`:

```{r add to sce}
# First, extract the colData into a separate data frame for manipulation
sce_coldata <- colData(sce) |>
  as.data.frame()

# Third, add columns as desired using the barcodes and cell_id columns to join
sce_coldata <- sce_coldata |>
  dplyr::left_join(
    cluster_results_renamed,
    by = c("barcodes" = "ropenscpca_cell_id")
  )

# Finally, add the modified colData back into the SCE
# Use the row.names argument to ensure rownames (barcodes) are retained; don't forget this step!
colData(sce) <- DataFrame(
  sce_coldata,
  row.names = sce_coldata$barcodes
)

# Print updated colData slot
colData(sce)
```

### Saving results to a Seurat object 

Follow these steps save the clustering results to a Seurat object's cell metadata:

```{r add to seurat}
# Add the cluster result data frame to the Seurat object metadata
seurat_obj <- AddMetaData(seurat_obj, cluster_results_renamed)

# Print the cell metadata
seurat_obj@meta.data
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
