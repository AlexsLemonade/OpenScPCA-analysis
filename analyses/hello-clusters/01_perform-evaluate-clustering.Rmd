---
title: "Performing and evaluating graph-based clustering with rOpenScPCA"
date: "`r Sys.Date()`"
author: "Data Lab"
params:
  seed: 2024
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    df_print: paged
---

## Introduction

This notebook provides examples of how to use the `rOpenScPCA` package to:

- Perform clustering
- Evaluate clustering results using several metrics, including:
  - Silhouette width
  - Neighborhood purity
  - Cluster stability, as measured with the Adjusted Rand Index
- Save clustering results

While this notebook does demonstrate how to use individual functions that evaluate a single clustering result, a full clustering evaluation would entail comparison these metrics across different clusterings from different parameterizations.


To demonstrate these tasks, this notebook will use the sample `SCPCS000001` from project `SCPCP000001`, which is assumed present in the `OpenScPCA-analysis/data/current/SCPCP000001` directory.
Please [see this documentation](https://openscpca.readthedocs.io/en/latest/getting-started/accessing-resources/getting-access-to-data/) for more information about obtaining ScPCA data.

## Setup

### Packages


```{r packages}
library(rOpenScPCA)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(Seurat)
  library(dplyr)
  library(ggplot2)
})

# Set ggplot theme
theme_set(theme_bw())
```

### Set the random seed

Because clustering involves random sampling, it is important to set the random seed at the top of your analysis script or notebook to ensure reproducibilty.

```{r set seed}
set.seed(params$seed)
```

### Paths

```{r base paths}
# The base path for the OpenScPCA repository
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The current data directory, found within the repository base directory
data_dir <- file.path(repository_base, "data", "current")

# The path to this module
module_base <- file.path(repository_base, "analyses", "hello-clusters")
```

### Input file

```{r paths}
# Path to processed SCE file for sample SCPCS000001
input_sce_file <- file.path(data_dir, "SCPCP000001", "SCPCS000001", "SCPCL000001_processed.rds")
```


### Read in data

To begin, we'll read in the `SingleCellExperiment` (SCE) object.
We'll also extract its PCA matrix, which we'll use to demonstrate how to calculate and evaluate clusters.


```{r read data}
# Read the SCE file
sce <- readRDS(input_sce_file)

# Extract the PCA matrix
pca_matrix <- reducedDim(sce, "PCA")
```

## Perform clustering

This section will show how to perform clustering with the function `rOpenScPCA::calculate_clusters()`. 

This function takes a PCA matrix with rownames representing unique cell ids (e.g., barcodes) as its primary argument.
By default it will calculate clusters using the following parameters:

* Louvain algorithm
* Jaccard weighting
* 10 nearest neighbors
* A resolution parameter of 1

This function will return a table with the following columns:

* `cell_id`: Unique cell identifiers, obtained from the PCA matrix's row names
* `cluster`: A factor column with the cluster identities
* There will be one column for each clustering parameter used


### Clustering with default parameters

```{r cluster sce}
# Calculate clusters with default parameters
cluster_results_df <- calculate_clusters(pca_matrix)

# Print resulting table
cluster_results_df
```

### Clustering with non-default parameters

Parameters used for clustering can be customized with these arguments:

* The `algorithm` can be one of:
  * `louvain`, `walktrap`, or `leiden`
* The `weighting` can be one of:
  * `jaccard`, `rank`, or `number`
* The nearest neighbors parameter can be customized with the `nn` argument
* The resolution parameter can be customized with the `resolution` argument
  * This parameter is only used by Louvain and Leiden algorithms
* If the Leiden algorithm is used, its default objective function parameter will be `CPM`, but you can also set  `objective_function = "modularity` instead.
* You can provide additional parameters as a list to the `cluster_args` argument.
  * Please refer to the [`igraph` documentation](https://igraph.org/r/html/latest) to learn more about what additional parameters can be provided to each clustering algorithm.
  * Note that `cluster_args` only accepts single-length arguments (no vectors or lists).

For example:

```{r cluster sce nondefault}
# Calculate clusters with non-default parameters
cluster_results_df <- calculate_clusters(
  pca_matrix,
  algorithm = "leiden",
  nn = 15,
  objective_function = "modularity"
)

# Print resulting table
cluster_results_df
```


## Evaluate clustering results

This section demonstrates how to use several functions for evaluating cluster quality and reliability. 
It's important to note that a full evaluation of clustering results would compare these metrics across a set of clustering results, with the aim of identifying an optimal parameterization.

All functions presented in this section take the following required arguments:

* A PCA matrix with rownames representing unique cell ids (e.g., barcodes)
* A data frame with, at least, columns representing unique cell ids and cluster assignments
  * By default, these columns should be named `cell_id` and `cluster`, respectively, matching the output of `rOpenScPCA::calculate_clusters()`
  * You can override these defaults using the arguments `cell_id_col` and `cluster_col`


### Silhouette width

Silhouette width is a common metric that measures how well separated clusters are by, for each cell, comparing the average distance to all cells in the same cluster, and all cells in other clusters.
This value ranges from -1 to 1.
Cells in well-separated clusters should have high silhouette values closer to 1.
You can read more about silhouette width purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#silhouette-width).

We'll use the function `rOpenScPCA::calculate_silhouette()` to calculate the silhouette width.

This function will return the inputted data frame with two additional columns:

* `silhouette_width`: The calculated silhouette width for the cell
* `silhouette_other`: The closet cluster to the cell besides the cluster to which it belongs, as used in the silhouette width calculation


```{r silhouette}
# calculate the silhouette width for each cell
silhouette_results <- calculate_silhouette(
  pca_matrix,
  cluster_results_df
)

# print result
silhouette_results
```


### Neighborhood purity

Neighborhood purity is defined, for each cell, as the proportion of neighboring cells that are assigned to the same cluster.
This value ranges from 0 to 1.
Cells in well-separated clusters should have high purity values closer to 1, since there should be minimal overlap between member and neighboring cells.
You can read more about neighborhood purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#cluster-purity).

We'll use the function `rOpenScPCA::calculate_purity()` to calculate the neighborhood purity.

This function will return the inputted data frame with two additional columns:

* `purity`: The neighborhood purity for the cell
* `maximum_neighbor`: The cluster with the highest proportion of observations neighboring the cell


```{r purity}
# calculate the neighborhood purity for each cell
purity_results <- calculate_purity(
  pca_matrix,
  cluster_results_df
)

# print result
purity_results
```

### Cluster stability

Another approach to exploring cluster quality is how stable the clusters themselves are using bootstrapping. 
Given a set of original clusters, we can compare the bootstrapped cluster identities to original ones using the Adjusted Rand Index (ARI), which measures the similarity of two data clusterings.
ARI ranges from -1 to 1, where:

* A value of 1 indicates they are completely overlapping
* A value of -1 indicates they are completely distinct
* A value of 0 indicates a random relationship

We expect that highly stable clusterings have ARI values closer to 1 across a set of bootstrap replicates.

You can read more about the Adjusted Rand Index from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/release/OSCA.advanced/clustering-redux.html#adjusted-rand-index).

We'll use the function `rOpenScPCA::calculate_stability()` to calculate the cluster stability.
By default, this function performs 20 bootstrap replicates, but this can be customized using the argument `replicates`.

This function will return a data frame with columns `replicate`, `ari`, and additional columns for the clustering parameters used when calculating bootstrap clusters.

```{r stability, warning=FALSE}
# calculate the stability of clusters
stability_results <- calculate_stability(
  sce,
  cluster_results_df
)

# print the result
stability_results
```

#### Using non-default clustering parameters

When calculating bootstrap clusters, `rOpenScPCA::calculate_stability()` uses `rOpenScPCA::calculate_clusters()` with default parameters. 
If your original clusters were not calculated with these defaults, you should pass those customized values into this function as well to ensure a fair comparison between your original clusters and the bootstrap clusters.


```{r stability custom parameters}
# Calculate clusters with non-default parameters
cluster_df_leiden <- calculate_clusters(
  sce,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)

# Now, pass in the same arguments customizing parameters here
stability_results_leiden <- calculate_stability(
  sce,
  cluster_df_leiden,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)

stability_results_leiden
```




## Working with objects directly

The above examples present how to work with a pca matrix, but you can also pass in an SCE or Seurat object with PCs to use instead.
When doing so, this package will assume a pc_name, and you will need to override this as needed.

When performing clustering on an SCE object, `rOpenScPCA::calculate_clusters()` assumes that the principal components are stored in a reduced dimension slot named `PCA`.
The function assumes the PC name is `PCA`. 
If your SCE object has a different name for the principal components, you can provide the name with the argument `pc_name`.


When performing clustering on a Seurat object, `rOpenScPCA::calculate_clusters()` assumes that the principal components are stored in a reduced dimension slot named `pca`.
If your Seurat object has a different name for the principal components, you can provide the name with the argument `pc_name`.
In this example, because we created the Seurat object from the SCE object, its principal components are named `PCA`, so we will provide that information.

```{r}
# Convert to a Seurat object for demonstration
seurat_obj <- as.Seurat(
  sce,
  counts = "counts",
  data = "logcounts"
)
```


### Clustering on a Seurat object



```{r cluster seurat}
cluster_results_df <- calculate_clusters(
  seurat_obj,
  # Since we converted this from an SCE object, its PC name is `PCA`
  pc_name = "PCA"
)


cluster_results_df
```



## Saving clustering results 

Results can either be directly exported as a TSV file (e.g., with `readr::write_tsv()`), or you can add the results into your scRNA-seq object.
The subsequent examples will show you, as an example, how to save the `cluster_results_df` data frame to a given object.


_A word of caution!_
Objects from the ScPCA Portal already contain a column called `cluster` with results from an automated clustering.
These automatic clusters were not evaluated, and their parameters were not optimized for any given library.

To avoid ambiguity between the existing and new clustering results, you may want to rename incoming columns.
We'll therefore begin by adding the prefix `ropenscpca_` to all column names in the `cluster_results_df` data frame before adding them to a given object.

```{r rename columns}
# First, rename columns in `cluster_results_df` to avoid ambiguity
cluster_results_renamed_df <- cluster_results_df |>
  # add the prefix openscpca_ to all columns
  dplyr::rename_with(~ paste0("ropenscpca_", .x))

cluster_results_renamed_df
```


### Saving results to an SCE object 

Follow these steps to save the clustering results to an SCE object's `colData`:

```{r add to sce}
# First, extract the colData into a separate data frame for manipulation
sce_coldata <- colData(sce) |>
  as.data.frame()

# Third, add columns as desired using the barcodes and cell_id columns to join
sce_coldata <- sce_coldata |>
  dplyr::left_join(
    cluster_results_renamed_df,
    by = c("barcodes" = "ropenscpca_cell_id")
  )

# Finally, add the modified colData back into the SCE
# Use the row.names argument to ensure rownames (barcodes) are retained; don't forget this step!
colData(sce) <- DataFrame(
  sce_coldata,
  row.names = sce_coldata$barcodes
)

# Print updated colData slot
colData(sce)
```

### Saving results to a Seurat object 

Follow these steps save the clustering results to a Seurat object's cell metadata:

```{r add to seurat}
# Add the cluster result data frame to the Seurat object metadata
seurat_obj <- AddMetaData(seurat_obj, cluster_results_renamed_df)

# Print the cell metadata
seurat_obj@meta.data
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
