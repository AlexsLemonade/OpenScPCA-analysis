---
title: "Performing and evaluating graph-based clustering with rOpenScPCA"
date: "`r Sys.Date()`"
author: "Data Lab"
params:
  seed: 2024
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    df_print: paged
---

## Introduction

This notebook provides examples of how to use the `rOpenScPCA` package to:

- Perform clustering
- Evaluate clustering results using several metrics, including:
  - Silhouette width
  - Neighborhood purity
  - Cluster stability, as measured with the Adjusted Rand Index
- Save clustering results

While this notebook does demonstrate how to use individual functions that evaluate a single clustering result, a full clustering evaluation would entail comparison these metrics across different clusterings from different parameterizations.


To demonstrate these tasks, this notebook will use the sample `SCPCS000001` from project `SCPCP000001`, which is assumed present in the `OpenScPCA-analysis/data/current/SCPCP000001` directory.
Please [see this documentation](https://openscpca.readthedocs.io/en/latest/getting-started/accessing-resources/getting-access-to-data/) for more information about obtaining ScPCA data.

## Setup

### Packages


```{r packages}
library(rOpenScPCA)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(Seurat)
  library(dplyr)
  library(ggplot2)
})

# Set ggplot theme
theme_set(theme_bw())
```

### Set the random seed

Because clustering involves random sampling, it is important to set the random seed at the top of your analysis script or notebook to ensure reproducibilty.

```{r set seed}
set.seed(params$seed)
```

### Paths

```{r base paths}
# The base path for the OpenScPCA repository
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The current data directory, found within the repository base directory
data_dir <- file.path(repository_base, "data", "current")

# The path to this module
module_base <- file.path(repository_base, "analyses", "hello-clusters")
```

### Input file

```{r paths}
# Path to processed SCE file for sample SCPCS000001
input_sce_file <- file.path(data_dir, "SCPCP000001", "SCPCS000001", "SCPCL000001_processed.rds")
```


### Read in data

To begin, we'll read in the `SingleCellExperiment` (SCE) object.

```{r read data}
# Read the SCE file
sce <- readRDS(input_sce_file)
```

We'll also extract its PCA matrix, which we'll use to demonstrate how to calculate and evaluate clusters.


```{r extract pca data}
# Extract the PCA matrix
pca_matrix <- reducedDim(sce, "PCA")
```

If you are working with a Seurat object, you can extract the PCA matrix like this:

```{r convert to seurat}
# First, convert the SCE to a Seurat object for demonstration


# Here, the PCA matrix has the same name as a
```


## Perform clustering

This section will show how to perform clustering with the function `rOpenScPCA::calculate_clusters()`. 

This function takes a PCA matrix with rownames representing unique cell ids (e.g., barcodes) as its primary argument.
By default it will calculate clusters using the following parameters:

* Louvain algorithm
* Jaccard weighting
* 10 nearest neighbors
* A resolution parameter of 1

This function will return a table with the following columns:

* `cell_id`: Unique cell identifiers, obtained from the PCA matrix's row names
* `cluster`: A factor column with the cluster identities
* There will be one column for each clustering parameter used


### Clustering with default parameters

```{r cluster sce}
# Calculate clusters with default parameters
cluster_results_df <- calculate_clusters(pca_matrix)

# Print resulting table
cluster_results_df
```

### Clustering with non-default parameters

Parameters used for clustering can be customized with these arguments:

* The `algorithm` can be one of:
  * `louvain`, `walktrap`, or `leiden`
* The `weighting` can be one of:
  * `jaccard`, `rank`, or `number`
* The nearest neighbors parameter can be customized with the `nn` argument
* The resolution parameter can be customized with the `resolution` argument
  * This parameter is only used by Louvain and Leiden algorithms
* If the Leiden algorithm is used, its default objective function parameter will be `CPM`, but you can also set  `objective_function = "modularity` instead.
* You can provide additional parameters as a list to the `cluster_args` argument.
  * Please refer to the [`igraph` documentation](https://igraph.org/r/html/latest) to learn more about what additional parameters can be provided to each clustering algorithm.
  * Note that `cluster_args` only accepts single-length arguments (no vectors or lists).

For example:

```{r cluster sce nondefault}
# Calculate clusters with non-default parameters
cluster_results_df <- calculate_clusters(
  pca_matrix,
  algorithm = "leiden",
  nn = 15,
  objective_function = "modularity"
)

# Print resulting table
cluster_results_df
```


## Evaluate clustering results

This section demonstrates how to use several functions for evaluating cluster quality and reliability. 
It's important to note that a full evaluation of clustering results would compare these metrics across a set of clustering results, with the aim of identifying an optimal parameterization.

All functions presented in this section take the following required arguments:

* A PCA matrix with row names representing unique cell ids (e.g., barcodes)
* A data frame with, at least, columns representing unique cell ids and cluster assignments
  * By default, these columns should be named `cell_id` and `cluster`, respectively, matching the output of `rOpenScPCA::calculate_clusters()`
  * You can override these defaults using the arguments `cell_id_col` and `cluster_col`

### Silhouette width

Silhouette width is a common metric that measures how well separated clusters are by, for each cell, comparing the average distance to all cells in the same cluster, and all cells in other clusters.
This value ranges from -1 to 1.
Cells in well-separated clusters should have high silhouette values closer to 1.
You can read more about silhouette width purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#silhouette-width).

We'll use the function `rOpenScPCA::calculate_silhouette()` to calculate the silhouette width.

This function will return the inputted data frame with two additional columns:

* `silhouette_width`: The calculated silhouette width for the cell
* `silhouette_other`: The closet cluster to the cell besides the cluster to which it belongs, as used in the silhouette width calculation


```{r silhouette}
# calculate the silhouette width for each cell
silhouette_results <- calculate_silhouette(
  pca_matrix,
  cluster_results_df
)

# print result
silhouette_results
```


### Neighborhood purity

Neighborhood purity is defined, for each cell, as the proportion of neighboring cells that are assigned to the same cluster.
This value ranges from 0 to 1.
Cells in well-separated clusters should have high purity values closer to 1, since there should be minimal overlap between member and neighboring cells.
You can read more about neighborhood purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#cluster-purity).

We'll use the function `rOpenScPCA::calculate_purity()` to calculate the neighborhood purity.

This function will return the inputted data frame with two additional columns:

* `purity`: The neighborhood purity for the cell
* `maximum_neighbor`: The cluster with the highest proportion of observations neighboring the cell


```{r purity}
# calculate the neighborhood purity for each cell
purity_results <- calculate_purity(
  pca_matrix,
  cluster_results_df
)

# print result
purity_results
```

### Cluster stability

Another approach to exploring cluster quality is how stable the clusters themselves are using bootstrapping. 
Given a set of original clusters, we can compare the bootstrapped cluster identities to original ones using the Adjusted Rand Index (ARI), which measures the similarity of two data clusterings.
ARI ranges from -1 to 1, where:

* A value of 1 indicates they are completely overlapping
* A value of -1 indicates they are completely distinct
* A value of 0 indicates a random relationship

We expect that highly stable clusterings have ARI values closer to 1 across a set of bootstrap replicates.

You can read more about the Adjusted Rand Index from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/release/OSCA.advanced/clustering-redux.html#adjusted-rand-index).

We'll use the function `rOpenScPCA::calculate_stability()` to calculate the cluster stability.
By default, this function performs 20 bootstrap replicates, but this can be customized using the argument `replicates`.

This function will return a data frame with columns `replicate`, `ari`, and additional columns for the clustering parameters used when calculating bootstrap clusters.

```{r stability, warning=FALSE}
# calculate the stability of clusters
stability_results <- calculate_stability(
  sce,
  cluster_results_df
)

# print the result
stability_results
```

#### Using non-default clustering parameters

When calculating bootstrap clusters, `rOpenScPCA::calculate_stability()` uses `rOpenScPCA::calculate_clusters()` with default parameters. 
If your original clusters were not calculated with these defaults, you should pass those customized values into this function as well to ensure a fair comparison between your original clusters and the bootstrap clusters.


```{r stability custom parameters}
# Calculate clusters with non-default parameters
cluster_df_leiden <- calculate_clusters(
  sce,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)

# Now, pass in the same arguments customizing parameters here
stability_results_leiden <- calculate_stability(
  sce,
  cluster_df_leiden,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)

stability_results_leiden
```



## Evaluating pre-calculated clusters

Even if you perform clustering with other tools, you can still use the `rOpenScPCA` functions to evaluate your clusters.
For example, if you are analyzing your data with a Seurat pipeline, you might also calculate clusters with Seurat, and you can evaluate those with `rOpenScPCA`.
In addition, ScPCA data already contains a column called `cluster` with results from an automated clustering.


In this section, we'll present how you can calculate the silhouette width and neighborhood purity from existing cluster assignments.


### Evaluating Seurat clusters

First, we'll prepare a Seurat object and perform clustering for demonstration:

```{r process seurat object}
# Convert to a Seurat object
seurat_obj <- CreateSeuratObject(counts = counts(sce), assay = "RNA")

# Process the object with a Seurat pipeline to obtain clusters
seurat_obj <- seurat_obj |>
  SCTransform() |>
  RunPCA() |>
  FindNeighbors(dims = 1:30) |>
  FindClusters()

# Print resulting clusters
head(seurat_obj$seurat_clusters)
```


Next, we'll prepare inputs for `rOpenScPCA` functions:

- The PCA matrix
- A data frame with columns `cell_id` and `cluster`

```{r prepare seurat input}
# Extract the PCA matrix
seurat_pca_matrix <- Embeddings(seurat_obj, reduction = "pca")

# Create a data frame
seurat_cluster_df <- data.frame(
  cell_id = names(seurat_obj$seurat_clusters),
  cluster = seurat_obj$seurat_clusters
)
```

Now, we can run `calculate_silhouette()` and `calculate_purity()`:

```{r seurat silhouette}
seurat_silhouette_df <- calculate_silhouette(
  seurat_pca_matrix,
  seurat_cluster_df
)
seurat_silhouette_df
```

```{r seurat purity}
seurat_purity_df <- calculate_purity(
  seurat_pca_matrix,
  seurat_cluster_df
)
seurat_purity_df
```

We do not recommend using `rOpenScPCA::calculate_stability()` on Seurat clusters due to differences in the underlying clustering approach between Seurat and the `bluster` package which `rOpenScPCA` uses.

### Evaluating ScPCA clusters

First, you should prepare a data frame two columns: `cell_id` containing cell barcodes, and `cluster` containing the cluster identities.

```{r}
scpca_cluster_df <- data.frame(
  cell_id = colnames(sce),
  cluster = colData(sce)$cluster
)

scpca_cluster_df
```

Then, you can proceed to run evaluation functions using this data frame, and the PCA matrix from the object.

```{r}
# Calculate silhouette width
scpca_silhouette_df <- calculate_silhouette(pca_matrix, scpca_cluster_df)
scpca_silhouette_df

# Calculate neighborhood purity
scpca_purity_df <- calculate_purity(pca_matrix, scpca_cluster_df)
scpca_purity_df
```

When running `calculate_stability()`, it is important to specify the same parameters originally used to build the clusters:

```{r}
scpca_stability_df <- calculate_stability(
  pca_matrix,
  scpca_cluster_df,
  # provide ScPCA clustering parameters
  algorithm = "louvain",
  weighting = "jaccard",
  nn = 20,
  resolution = 1
)
scpca_stability_df
```



### Working with objects directly

As presented above, `rOpenScPCA` clustering functions take a PCA matrix with row names representing unique cell ids as their first argument.

Instead of a matrix, you can alternatively pass in an SCE or Seurat object that contains PCs.
For example:

```{r}
# Calculate clusters from an SCE object using default parameters
cluster_results_df <- calculate_clusters(sce)

# Calculate clusters from a Seurat object using default parameters
cluster_results_df <- calculate_clusters(seurat_obj)
```


`rOpenScPCA` assumes that the PCA matrix is named `PCA` in SCE objects, and `pca` in Seurat objects.
If the PCA matrix you want to use in the object has a different name, you can provide the argument `pc_name`.
For example:

```{r}
# First, we'll rename the PCA matrix for demonstration
reducedDimNames(sce) <- c("PCA_matrix", "UMAP")

# Calculate clusters from an SCE object using default parameters
cluster_results_df <- calculate_clusters(
  sce,
  pc_name = "PCA_matrix"
)
```





## Saving clustering results 

Results can either be directly exported as a TSV file (e.g., with `readr::write_tsv()`), or you can add the results into your SCE or Seurat object.
The subsequent examples will show you, as an example, how to save the `cluster_results_df` data frame to a given object.


_A word of caution!_
Objects from the ScPCA Portal already contain a column called `cluster` with results from an automated clustering.
These automatic clusters were not evaluated, and their parameters were not optimized for any given library.

To avoid ambiguity between the existing and new clustering results, you may want to rename incoming columns.
We'll therefore begin by adding the prefix `ropenscpca_` to all column names in the `cluster_results_df` data frame before adding them to a given object.

```{r rename columns}
# First, rename columns in `cluster_results_df` to avoid ambiguity
cluster_results_renamed_df <- cluster_results_df |>
  # add the prefix openscpca_ to all columns
  dplyr::rename_with(~ paste0("ropenscpca_", .x))

cluster_results_renamed_df
```


### Saving results to an SCE object 

Follow these steps to save the clustering results to an SCE object's `colData`:

```{r add to sce}
# First, extract the colData into a separate data frame for manipulation
sce_coldata <- colData(sce) |>
  as.data.frame()

# Third, add columns as desired using the barcodes and cell_id columns to join
sce_coldata <- sce_coldata |>
  dplyr::left_join(
    cluster_results_renamed_df,
    by = c("barcodes" = "ropenscpca_cell_id")
  )

# Finally, add the modified colData back into the SCE
# Use the row.names argument to ensure rownames (barcodes) are retained; don't forget this step!
colData(sce) <- DataFrame(
  sce_coldata,
  row.names = sce_coldata$barcodes
)

# Print updated colData slot
colData(sce)
```

### Saving results to a Seurat object 

Follow these steps save the clustering results to a Seurat object's cell metadata:

```{r add to seurat}
# Add the cluster result data frame to the Seurat object metadata
seurat_obj <- AddMetaData(seurat_obj, cluster_results_renamed_df)

# Print the cell metadata
seurat_obj@meta.data
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
