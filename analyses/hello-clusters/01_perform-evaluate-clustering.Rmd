---
title: "Performing graph-based clustering with rOpenScPCA"
date: "`r Sys.Date()`"
author: "Data Lab"
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    df_print: paged
---

## Introduction

This notebook provides examples of how to use functions in `rOpenScPCA` that:

* Perform clustering
* Calculate QC metrics on clusters, including:
  * Silhouette width
  * Neighborhood purity
  * Cluster stability, as measured with the Adjusted Rand Index
* Calculate QC metrics on clusters obtained with other tools, such as `Seurat`
* Save clustering results to an SCE or `Seurat`

While this notebook demonstrates how to use individual functions that calculate helpful metrics for evaluating clustering results, a full evaluation would compare these metrics across different clusterings from different parameterizations.

This notebook will use the sample `SCPCS000001` from project `SCPCP000001`, which is assumed present in the `OpenScPCA-analysis/data/current/SCPCP000001` directory, for all examples.
Please [see this documentation](https://openscpca.readthedocs.io/en/latest/getting-started/accessing-resources/getting-access-to-data/) for more information about obtaining ScPCA data.

## Setup

### Packages


```{r packages}
library(rOpenScPCA)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(Seurat)
  library(dplyr)
})
```


### Paths

```{r base paths}
# The base path for the OpenScPCA repository
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The current data directory, found within the repository base directory
data_dir <- file.path(repository_base, "data", "current")

# The path to this module
module_base <- file.path(repository_base, "analyses", "hello-clusters")
```

```{r input file path}
# Path to processed SCE file for sample SCPCS000001
input_sce_file <- file.path(data_dir, "SCPCP000001", "SCPCS000001", "SCPCL000001_processed.rds")
```


### Set the random seed

Because clustering involves random sampling, it is important to set the random seed at the top of your analysis script or notebook to ensure reproducibility.

```{r set seed}
set.seed(2024)
```

## Read in and prepare data

To begin, we'll read in the `SingleCellExperiment` (SCE) object.
We'll also establish a corresponding processed Seurat object from its raw counts that we'll use for some examples.

```{r read data}
# Read the SCE file
sce <- readRDS(input_sce_file)
```

For the initial cluster calculations and evaluations, we will use the PCA matrix extracted from the SCE object.
It's also possible to use an SCE object or a Seurat object directly, which we will demonstrate later.


```{r extract pca data}
# Extract the PCA matrix from an SCE object
pca_matrix <- reducedDim(sce, "PCA")
```

## Perform clustering

This section will show how to perform clustering with the function `rOpenScPCA::calculate_clusters()`. 

This function takes a PCA matrix with rownames representing unique cell ids (e.g., barcodes) as its primary argument.
By default it will calculate clusters using the following parameters:

* Louvain algorithm
* Jaccard weighting
* 10 nearest neighbors
* A resolution parameter of 1

This function will return a table with the following columns:

* `cell_id`: Unique cell identifiers, obtained from the PCA matrix's row names
* `cluster`: A factor column with the cluster identities
* There will be one column for each clustering parameter used


### Clustering with default parameters

```{r cluster sce}
# Calculate clusters with default parameters
cluster_results_df <- rOpenScPCA::calculate_clusters(pca_matrix)

# Print the first rows of the resulting table
head(cluster_results_df)
```

### Clustering with non-default parameters

Parameters used for clustering can be customized with these arguments:

* The `algorithm` can be one of:
  * `louvain`, `walktrap`, or `leiden`
* The `weighting` can be one of:
  * `jaccard`, `rank`, or `number`
* The nearest neighbors parameter can be customized with the `nn` argument
* The resolution parameter can be customized with the `resolution` argument
  * This parameter is only used by Louvain and Leiden algorithms
* If the Leiden algorithm is used, its default objective function parameter will be `CPM`, but you can also set  `objective_function = "modularity"` instead.
* You can provide additional parameters as a list to the `cluster_args` argument.
  * Please refer to the [`igraph` documentation](https://igraph.org/r/html/latest) to learn more about what additional parameters can be provided to each clustering algorithm.
  * Note that `cluster_args` only accepts single-length arguments (no vectors or lists).

For example:

```{r cluster sce nondefault}
# Calculate clusters with non-default parameters
cluster_results_df <- rOpenScPCA::calculate_clusters(
  pca_matrix,
  algorithm = "leiden",
  nn = 15,
  objective_function = "modularity"
)
```


## Calculate QC metrics on clusters

This section demonstrates how to use several functions for evaluating cluster quality and reliability. 
It's important to note that a full evaluation of clustering results would compare these metrics across a set of clustering results, with the aim of identifying an optimal parameterization.

All functions presented in this section take the following required arguments:

* A PCA matrix with row names representing unique cell ids (e.g., barcodes)
* A data frame with, at least, columns representing unique cell ids and cluster assignments
  * By default, these columns should be named `cell_id` and `cluster`, respectively, matching the output of `rOpenScPCA::calculate_clusters()`
  * You can override these defaults using the arguments `cell_id_col` and `cluster_col`

### Silhouette width

Silhouette width is a common metric that measures how well separated clusters are by, for each cell, comparing the average distance to all cells in the same cluster, and all cells in other clusters.
This value ranges from -1 to 1.
Cells in well-separated clusters should have high silhouette values closer to 1.
You can read more about silhouette width purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#silhouette-width).

We'll use the function `rOpenScPCA::calculate_silhouette()` to calculate the silhouette width.

This function will return the inputted data frame with two additional columns:

* `silhouette_width`: The calculated silhouette width for the cell
* `silhouette_other`: The closet cluster to the cell besides the cluster to which it belongs, as used in the silhouette width calculation


```{r silhouette}
# calculate the silhouette width for each cell
silhouette_results <- rOpenScPCA::calculate_silhouette(
  pca_matrix,
  cluster_results_df
)

# Print the first rows of the resulting table
head(silhouette_results)
```


### Neighborhood purity

Neighborhood purity is defined, for each cell, as the proportion of neighboring cells that are assigned to the same cluster.
This value ranges from 0 to 1.
Cells in well-separated clusters should have high purity values closer to 1, since there should be minimal overlap between member and neighboring cells.
You can read more about neighborhood purity from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/3.19/OSCA.advanced/clustering-redux.html#cluster-purity).

We'll use the function `rOpenScPCA::calculate_purity()` to calculate the neighborhood purity.

This function will return the inputted data frame with two additional columns:

* `purity`: The neighborhood purity for the cell
* `maximum_neighbor`: The cluster with the highest proportion of observations neighboring the cell


```{r purity}
# calculate the neighborhood purity for each cell
purity_results <- rOpenScPCA::calculate_purity(
  pca_matrix,
  cluster_results_df
)

# Print the first rows of the resulting table
head(purity_results)
```

### Cluster stability

Another approach to exploring cluster quality is how stable the clusters themselves are using bootstrapping. 
Given a set of original clusters, we can compare the bootstrapped cluster identities to original ones using the Adjusted Rand Index (ARI), which measures the similarity of two data clusterings.
ARI ranges from -1 to 1, where:

* A value of 1 indicates they are completely overlapping
* A value of -1 indicates they are completely distinct
* A value of 0 indicates a random relationship

We expect that highly stable clusterings have ARI values closer to 1 across a set of bootstrap replicates.

You can read more about the Adjusted Rand Index from the [_Orchestrating Single Cell Analysis with Bioconductor_ book](https://bioconductor.org/books/release/OSCA.advanced/clustering-redux.html#adjusted-rand-index).

We'll use the function `rOpenScPCA::calculate_stability()` to calculate the cluster stability.
By default, this function performs 20 bootstrap replicates, but this can be customized using the argument `replicates`.

This function will return a data frame with columns `replicate`, `ari`, and additional columns for the clustering parameters used when calculating bootstrap clusters.

```{r stability, warning=FALSE}
# calculate the stability of clusters
stability_results <- rOpenScPCA::calculate_stability(
  pca_matrix,
  cluster_results_df
)

# print the result
stability_results
```

#### Using non-default clustering parameters

When calculating bootstrap clusters, `rOpenScPCA::calculate_stability()` uses `rOpenScPCA::calculate_clusters()` with default parameters. 
If your original clusters were not calculated with these defaults, you should pass those customized values into this function as well to ensure a fair comparison between your original clusters and the bootstrap clusters.


```{r stability custom parameters}
# Calculate clusters with non-default parameters
cluster_df_leiden <- rOpenScPCA::calculate_clusters(
  pca_matrix,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)

# Now, pass in the same arguments customizing parameters here
stability_results_leiden <- rOpenScPCA::calculate_stability(
  pca_matrix,
  cluster_df_leiden,
  algorithm = "leiden",
  resolution = 0.5,
  nn = 15
)
```


## Working with objects directly

As presented above, `rOpenScPCA` clustering functions take a PCA matrix with row names representing unique cell ids as their first argument.

Instead of a matrix, you can alternatively pass in an SCE or Seurat object that contains a matrix.

We show an example of this below with and SCE object and `rOpenScPCA::calculate_clusters()`, but this will also work for any of the evaluation functions as well and has the same syntax for Seurat objects.

```{r run on sce}
# Calculate clusters from an SCE object using default parameters
cluster_results_df <- rOpenScPCA::calculate_clusters(sce)
cluster_results_df
```


`rOpenScPCA` assumes that the PCA matrix is named `PCA` in SCE objects, and `pca` in Seurat objects.
If the PCA matrix you want to use in the object has a different name, you can provide the argument `pc_name`.


## Calculating QC metrics on existing clusters

If you already have clustering results calculated with other tools, you can still use the `rOpenScPCA` functions to evaluate your clusters.

In this section, we'll present examples of how you can calculate the silhouette width, neighborhood purity, and cluster stability from existing cluster assignments within objects.

### Evaluating Seurat clusters

If you are analyzing your data with a Seurat pipeline that includes calculating clusters, you can use `rOpenScPCA` to evaluate them.

To demonstrate this, we'll convert our SCE object to a Seurat using the function `rOpenScPCA::sce_to_seurat()`.
We'll set `use_symbols = FALSE` to preserve Ensembl ids as the feature names rather than converting to gene symbols.
Then, we'll use a simple Seurat pipeline to obtain clusters.

```{r sce to seurat, message = FALSE}
# Convert the SCE to a Seurat object using rOpenScPCA, preserving Ensembl ids as feature names
seurat_obj <- rOpenScPCA::sce_to_seurat(sce, use_symbols = FALSE)

# Calculate clusters with Seurat
seurat_obj <- seurat_obj |>
  SCTransform() |>
  RunPCA() |>
  FindNeighbors() |>
  FindClusters()

seurat_obj
```


To calculate QC metrics on these clusters, we'll need to create a data frame with columns `cell_id` and `cluster`:

```{r prepare seurat input}
# Create a data frame for input
seurat_cluster_df <- data.frame(
  cell_id = colnames(seurat_obj),
  cluster = seurat_obj$seurat_clusters
)

head(seurat_cluster_df)
```

Now, we can run `rOpenScPCA::calculate_silhouette()` and `rOpenScPCA::calculate_purity()` using this data frame and the Seurat object:

```{r seurat silhouette}
seurat_silhouette_df <- rOpenScPCA::calculate_silhouette(
  seurat_obj,
  seurat_cluster_df
)
```

```{r seurat purity}
seurat_purity_df <- rOpenScPCA::calculate_purity(
  seurat_obj,
  seurat_cluster_df
)
```

We do not recommend using `rOpenScPCA::calculate_stability()` on Seurat clusters due to differences in the underlying clustering approach between Seurat and the `bluster` package which `rOpenScPCA` uses.

### Evaluating ScPCA clusters

ScPCA cell metadata already contains a column called `cluster` with results from an automated clustering. 
These clusters were calculated using `bluster`, the same tool that `rOpenScPCA` uses. 
We can see the parameters it used from the SCE object's metadata; all other parameters were left at their default values.

```{r extract cluster params}
# Print the clustering algorithm used
metadata(sce)$cluster_algorithm

# Print the weighting scheme
metadata(sce)$cluster_weighting

# Print the number of nearest neighbors
metadata(sce)$cluster_nn
```


In this example, we'll show how to use the cluster evaluation functions on these clusters.

To begin, we'll prepare a data frame with two columns: `cell_id` containing cell barcodes, and `cluster` containing the cluster identities.

```{r prepare scpca data frame}
scpca_cluster_df <- data.frame(
  cell_id = colnames(sce),
  cluster = sce$cluster
)

head(scpca_cluster_df)
```

We can run evaluation functions using this data frame and the SCE object.

```{r scpca silhouette}
# Calculate silhouette width
scpca_silhouette_df <- rOpenScPCA::calculate_silhouette(
  sce,
  scpca_cluster_df
)
```

```{r scpca purity}
# Calculate neighborhood purity
scpca_purity_df <- rOpenScPCA::calculate_purity(
  sce,
  scpca_cluster_df
)
```

When running `rOpenScPCA::calculate_stability()`, we'll specify the same parameters originally used to build the clusters.
Generally speaking, we only recommend evaluating clusters with `rOpenScPCA::calculate_stability()` if you know the original parameters used.

```{r scpca stability}
scpca_stability_df <- rOpenScPCA::calculate_stability(
  sce,
  scpca_cluster_df,
  # provide ScPCA clustering parameters
  algorithm = "louvain",
  weighting = "jaccard",
  nn = 20
)
```


## Saving clustering results 

Results can either be directly exported as a TSV file (e.g., with `readr::write_tsv()`), or you can add the results into your SCE or Seurat object.
The subsequent examples will show you how to save the `cluster_results_df` data frame to an SCE and a Seurat object.

_A word of caution!_
Objects from the ScPCA Portal already contain a column called `cluster` with results from an automated clustering.
These automatic clusters were not evaluated, and their parameters were not optimized for any given library.

To avoid ambiguity between the existing and new clustering results, you may want to rename incoming columns.

We'll therefore begin by adding the prefix `ropenscpca_` to all column names in the `cluster_results_df` data frame before adding them to a given object.

```{r rename columns}
# First, rename columns in `cluster_results_df` to avoid ambiguity
cluster_results_renamed_df <- cluster_results_df |>
  # add the prefix "ropenscpca_" to all columns
  dplyr::rename_with(\(x) paste0("ropenscpca_", x))

cluster_results_renamed_df
```


### Saving results to an SCE object 

Follow these steps to save the clustering results to an SCE object's `colData`:

```{r add to sce}
# First, extract the colData into a separate data frame for manipulation
sce_coldata <- colData(sce) |>
  as.data.frame()

# Second, add columns as desired using the barcodes and cell_id columns to join
sce_coldata <- sce_coldata |>
  dplyr::left_join(
    cluster_results_renamed_df,
    by = c("barcodes" = "ropenscpca_cell_id")
  )

# Third, add the modified colData back into the SCE
# Use the row.names argument to ensure rownames (barcodes) are retained; don't forget this step!
colData(sce) <- DataFrame(
  sce_coldata,
  row.names = sce_coldata$barcodes
)

head(colData(sce))
```

### Saving results to a Seurat object 

Follow these steps save the clustering results to a Seurat object's cell metadata.
Note that the Seurat function `AddMetaData()`, used below, assumes that the row order in the provided data frame matches the order of cells in the Seurat object you're adding metadata to.

```{r add to seurat}
# Add the cluster result data frame to the Seurat object metadata
seurat_obj <- AddMetaData(seurat_obj, cluster_results_renamed_df)

# Print the cell metadata
head(seurat_obj@meta.data)
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
