---
title: "`r glue::glue('inferCNV results for {params$library_id}')`"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
params:
  library_id: SCPCL000822
  sample_id: SCPCS000490
---


## Introduction

This notebook explores `inferCNV` results run on library `params$library_id` from `SCPCP000015`.
`inferCNV` was run with three different normal references:

* `endo`: All consensus endothelial cells across `SCPCP000015` libraries, _excluding_ any which were also identified as tumor in the `cell-type-ewings` analysis module
* `immune`: All consensus immune cells across `SCPCP000015` libraries, _excluding_ any which were also identified as tumor in the `cell-type-ewings` analysis module
* `endo-immune`: The `endo` and `immune` references combined

`inferCNV` was run with default settings, including:

* The `i6` HMM
* The setting `analysis_mode = "subclusters"`, which allows the HMM to call CNVs at the level of clusters rather than whole samples or individual cells
* Default clustering parameters

## Setup

```{r}
options(readr.show_col_types = FALSE)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(ggplot2)
  library(patchwork)
})

theme_set(theme_bw())

umap_theme <- list(
  coord_fixed(),
  theme_classic(),
  theme(
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )
)
```


### Paths

#### Base directories

```{r base paths}
# repo and analysis base dirs
repository_base <- rprojroot::find_root(rprojroot::is_git_root)
analysis_dir <- file.path(repository_base, "analyses", "infercnv-consensus-cell-type")

# reference names, defined here to help define directories
ref_names <- c("ref_endo", "ref_immune", "ref_endo-immune")

# inferCNV directories
infercnv_dir <- file.path(analysis_dir, "results", "SCPCP000015", params$sample_id)
infercnv_dirs <- file.path(infercnv_dir, ref_names)
names(infercnv_dirs) <- ref_names

# OpenScpCA data and results directories
data_dir <- file.path(repository_base, "data", "current")
```

#### Input files

```{r paths}
# TSV with expected Ewing CNVs
validation_tsv <- file.path(analysis_dir, "references", "cnv-validation.tsv")

# immune cell URL to check for ambiguous cell types
immune_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-immune-cell-types.tsv"

# processed sce file
sce_file <- file.path(
  data_dir,
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_processed.rds")
)


# consensus cell types, which we'll grab from the ewings results for now
# TODO: We currently are bringing in cell types from separate files, but in the next
# data release they will be in the SCE objects so we won't need this tsv
ewings_tsv <- file.path(
  data_dir,
  "results",
  "cell-type-ewings",
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_ewing-celltype-assignments.tsv")
)
```

### Read in data

```{r message = FALSE}
validation_df <- readr::read_tsv(validation_tsv) |>
  dplyr::filter(diagnosis == "Ewing sarcoma")

immune_labels <- readr::read_tsv(immune_url) |>
  dplyr::pull(consensus_annotation)


# read infercnv files
infercnv_df <- infercnv_dirs |>
  purrr::map(
    \(input_dir) {
      readr::read_tsv(
        file.path(input_dir, glue::glue("{params$library_id}_cnv-metadata.tsv"))
      ) |>
        # indicator for reference vs query cell based on `subcluster` name
        dplyr::mutate(cell_group = stringr::str_split_i(subcluster, "_", 1)) |>
        # separate barcode and library
        tidyr::separate(
          cell_id,
          sep = "-",
          into = c("library_id", "barcodes"),
          remove = FALSE
        )
    }
  ) |>
  purrr::list_rbind(names_to = "normal_reference")


# Extract a version of the data frame with just the infercnv metadata, not CNVs themselves
infercnv_metadata_df <- infercnv_df |>
  dplyr::select(
    -starts_with("has_"),
    -starts_with("proportion_"),
    -starts_with("top_")
  )

# Read SCE and save UMAP coordinates and cell types
umap_df <- readr::read_rds(sce_file) |>
  scuttle::makePerCellDF(use.dimred = "UMAP") |>
  dplyr::select(
    barcodes,
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2
  )

# TODO: We currently are bringing in cell types from separate files, but in the next
# data release they will be in the SCE objects this could be part of the colData wrangling above.
celltype_df <- readr::read_tsv(ewings_tsv) |>
  # Label cells as:
  # - tumor-immune: Cells labeled as tumor by cell-type-ewings, but immune by cell-type-consensus
  # - tumor: Cells labeled as tumor by cell-type-ewings
  # - their existing ewing_annotation if none of the above
  dplyr::mutate(
    celltype = dplyr::case_when(
      ## tumor-immune
      consensus_annotation %in% immune_labels &
        stringr::str_starts(ewing_annotation, "tumor") ~ "tumor-immune",
      ## tumor
      stringr::str_starts(ewing_annotation, "tumor") ~ "tumor",
      ## default
      .default = ewing_annotation
    )
  ) |>
  dplyr::select(barcodes, celltype)

umap_df <- umap_df |>
  dplyr::left_join(celltype_df)
```


## InferCNV Heatmaps

Below, we show the `inferCNV` heatmaps from the `immune-all` and `immune-subset` normal references for this library.

To help contextualize these, here is the table of known CNVs in Ewing sarcoma we'll use for validation:

```{r}
validation_df
```


```{r}
# define the pngs
infercnv_pngs <- file.path(infercnv_dirs, glue::glue("{params$library_id}_infercnv.png"))
names(infercnv_pngs) <- ref_names
```
### Reference with all endothelial cells

![InferCNV heatmap with endo reference](`r infercnv_pngs["endo"]`)

### Reference with all immune cells

![InferCNV heatmap with immune reference](`r infercnv_pngs["immune"]`)

### Reference with both endothelial and immune cells

![InferCNV heatmap with end-immune reference](`r infercnv_pngs["endo-immune"]`)



## Distribution of CNVs per cell

This section contains figures showing the total number of CNVs detected per cell.

### CNVs in reference vs query cells

The figures below compare the number of CNVs per cell between reference and query cells.
Ideally, we'll see a bimodal distribution where reference cells are at/near zero, and there is a peak of higher values which may represent tumor cells.
In the density plots below, distributions are colored based on whether the cells are in the reference or not (aka, "unknown" cells).

```{r}
# First, construct data frame of total `has_cnv` counts, with other variables needed for plots
has_cnv_df <- infercnv_df |>
  dplyr::select(
    library_id,
    barcodes,
    normal_reference,
    starts_with("has_cnv_")
  ) |>
  tidyr::pivot_longer(
    starts_with("has_cnv_"),
    names_to = "chr",
    values_to = "cnv"
  ) |>
  # sum all values for each cell, but separately for each run of inferCNV (aka each normal reference)
  dplyr::group_by(library_id, barcodes, normal_reference) |>
  dplyr::summarize(total_cnv_per_cell = sum(cnv)) |>
  dplyr::ungroup() |>
  # bring back metadata
  dplyr::inner_join(
    infercnv_metadata_df,
    by = c("library_id", "barcodes", "normal_reference")
  ) |>
  # join in SCE information
  dplyr::left_join(umap_df) |>
  # set levels
  dplyr::mutate(normal_reference = factor(normal_reference, levels = ref_names))
```


```{r fig.width = 10, fig.height = 5}
ggplot(has_cnv_df) +
  aes(x = total_cnv_per_cell, fill = cell_group) +
  geom_density(alpha = 0.5) +
  facet_wrap(vars(normal_reference)) +
  theme(legend.position = "bottom")
```

### CNVs across cell types

Next, we'll look at the per-cell distributions of CNVs across cell types.
Specifically, we'll look at both the cell types from the `cell-type-consensus` module and the `cell-type-ewings` module separately.

Ideally, we'll see that tumor and Unknown cells from `cell-type-consensus` and cells labeled as tumor in `cell-type-ewings` will have relatively higher CNV scores compared to other cell types.

In addition, it will be useful to:

* See values for cells labeled `tumor-immune`, which were labeled as `tumor` by `cell-type-ewings` but as an immune cell type by `cell-type-consensus`
* Compare distributions between `all-immune` and `subset-immune` which may support identifying the optimal normal reference strategy.

```{r fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
# drop cells from other libraries
query_has_cnv_df <- has_cnv_df |>
  dplyr::filter(library_id == params$library_id)

ggplot(query_has_cnv_df) +
  aes(
    x = celltype,
    y = total_cnv_per_cell,
    fill = normal_reference
  ) +
  geom_boxplot(linewidth = 0.25, outlier.size = 0.25) +
  scale_fill_brewer(palette = "Pastel2") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



## UMAPs

Next, we'll visualize the total CNV counts as a UMAP.

First, as a guide to interpret the UMAP, let's color by cell types.

```{r, fig.width = 6}
ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = celltype) +
  geom_point(size = 0.1, alpha = 0.3) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1))) +
  umap_theme
```

Next, the total CNVs per cell; ideally, higher values will overlap with regions in the UMAP containing putative tumor cells.

```{r fig.width=10, warning = FALSE}
# noting we expect warnings with this plot since there's no UMAP coordinates
# for cells from other libraries in the reference
ggplot(has_cnv_df) +
  aes(x = UMAP1, y = UMAP2, color = total_cnv_per_cell) +
  geom_point(size = 0.1, alpha = 0.3) +
  scale_color_viridis_c() +
  facet_wrap(vars(normal_reference)) +
  labs(title = "Total CNV per cell") +
  umap_theme
```

## Clusters

Part of `inferCNV`'s algorithm involves clustering the data, and poor clusters have the potential to lead to inaccurate inferences of CNV.
To see whether we'd like to further tune the clustering parameters, we'll get a sense of their size and rough composition here.

How many clusters are there, and how big are they?

```{r}
has_cnv_df |>
  dplyr::count(subcluster) |>
  dplyr::group_by(subcluster) |>
  dplyr::arrange(desc(n))
```


```{r}
summary(as.numeric(table(has_cnv_df$subcluster)))
```

Is there any relationship between cluster size and the number of CNVs?
We would ideally not want there to be a relationship since this might indicate a bias.

```{r}
cluster_size_df <- has_cnv_df |>
  dplyr::add_count(subcluster, name = "cluster_size") |>
  dplyr::select(
    total_cnv_per_cell,
    cluster_size,
    normal_reference
  ) |>
  dplyr::distinct()

ggplot(cluster_size_df) +
  aes(x = cluster_size, y = total_cnv_per_cell) +
  geom_point() +
  facet_wrap(vars(normal_reference)) +
  geom_smooth(method = "lm")
```


Let's also look more specifically at the `reference` clusters, where we might expect some batch effects since cells were taken from several different libraries.
Do originating libraries cluster together?

```{r}
reference_cells_df <- has_cnv_df |>
  dplyr::filter(cell_group == "reference")

ggplot(reference_cells_df) +
  aes(x = subcluster, fill = library_id) +
  geom_bar() +
  facet_wrap(
    vars(normal_reference),
    scales = "free_x"
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_blank()
  )
```


## CNV across chromosomes

Now, we'll look at CNVs across chromosomes, specifically considering the `proportion_scaled_cnv_` output from the HMM.

Again, these are the specific CNVs we expect to see in Ewing sarcoma:

```{r}
validation_df
```

```{r}
# First, construct data frame with proportion_scaled_ instead of has_cnv
prop_cnv_df <- infercnv_df |>
  dplyr::select(
    library_id,
    barcodes,
    normal_reference,
    starts_with("proportion_scaled_")
  ) |>
  tidyr::pivot_longer(
    starts_with("proportion_scaled_"),
    names_to = "cnv_type_raw",
    values_to = "proportion"
  ) |>
  # more tidying
  dplyr::mutate(cnv_type_raw = stringr::str_remove(cnv_type_raw, "^proportion_scaled_")) |>
  tidyr::separate(cnv_type_raw, sep = "_", into = c("cnv_type", "chr")) |>
  # remove extra chromosomes and cells not in this library
  dplyr::filter(
    !stringr::str_starts(chr, "chrMT"),
    !stringr::str_starts(chr, "chrGL"),
    library_id == params$library_id
  ) |>
  dplyr::mutate(
    chr = stringr::str_remove(chr, "^chr"),
    # set factor levels
    chr = factor(chr, levels = 1:22),
    normal_reference = factor(normal_reference, levels = ref_names),
    chr = forcats::fct_relevel(chr, as.character(validation_df$chromosome))
  )
```

We'll make density plots of the predicted CNV events across chromosomes, for each of the normal references:
The panels will be ordered first by the chromosomes with known CNVs, and then in order for the rest of the chromosomes.


```{r fig.height=40, fig.width=8}
ggplot(prop_cnv_df) +
  aes(
    x = proportion,
    color = cnv_type
  ) +
  geom_density() +
  # use wrap to get truly free scales
  facet_wrap(
    vars(chr, normal_reference),
    scales = "free",
    labeller = "label_both",
    ncol = 3
  ) +
  theme(strip.text = element_text(size = 8))
```

## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
