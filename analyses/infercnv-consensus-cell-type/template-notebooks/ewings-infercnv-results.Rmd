---
title: "`r glue::glue('Initial inferCNV results for {params$library_id}')`"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
params:
  sample_id: SCPCS000490
  library_id: SCPCL000822
---


## Introduction

This notebook explores `inferCNV` results run on library `params$library_id` from `SCPCP000015`.
`inferCNV` was run with two different normal references:

* `all-immune`: All consensus immune cells across `SCPCP000015` libraries, _excluding_ any which were also identified as tumor in the `cell-type-ewings` analysis module
* `subset-immnune`: A subset of `all-immune`, considering only macrophage and T-cell cell types

`inferCNV` was run with the following settings:

* We used the `i3` HMM which has improved run times relative to their `i6` HMM
* We used the default `analysis_mode = "subclusters"`, which allows the HMM to call CNVs at the level of clusters rather than whole samples or individual cells
* We used the following clustering parameters:
  * Leiden clustering run on PCA (not the expression matrix)
  * `k=20` nearest neighbors with a `resolution` parameter of 1 and using the `modularity` objective function 


## Setup

```{r}
options(readr.show_col_types = FALSE)

library(SingleCellExperiment)
library(ggplot2)
library(patchwork)

# Set default ggplot theme, customized for UMAPs
theme_set(theme_bw())

umap_theme <- list(
  coord_fixed(),
  theme_classic(),
  theme(
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )
)
```

### Paths

#### Base directories

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# InferCNV directories
analysis_dir <- file.path(repository_base, "analyses", "infercnv-consensus-cell-type")
ref_dir <- file.path(analysis_dir, "references")
infercnv_dir <- file.path(analysis_dir, "results", "SCPCP000015", params$sample_id)
infercnv_immune_dir <- file.path(infercnv_dir, "ref-all-immune")
infercnv_subset_dir <- file.path(infercnv_dir, "ref-subset-immune")

# OpenScpCA data and results directories
data_dir <- file.path(repository_base, "data", "current")
```

#### Input and output files

```{r paths}
# TSV with expected Ewing CNVs
validation_tsv <- file.path(ref_dir, "cnv-validation.tsv")

# References themselves so we know which cells belong to reference
immune_ref_sce_file <- file.path(ref_dir, "normal-references", "SCPCP000015", "ref-all-immune.rds")
subset_ref_sce_file <- file.path(ref_dir, "normal-references", "SCPCP000015", "ref-subset-immune.rds")

# input infercnv files from both references, "all-immune" and "subset-immune"
immune_hmm_tsv <- file.path(infercnv_immune_dir, glue::glue("{params$library_id}_cnv-metadata.tsv"))
immune_png <- file.path(infercnv_immune_dir, glue::glue("{params$library_id}_infercnv.png"))
subset_hmm_tsv <- file.path(infercnv_subset_dir, glue::glue("{params$library_id}_cnv-metadata.tsv"))
subset_png <- file.path(infercnv_subset_dir, glue::glue("{params$library_id}_infercnv.png"))

# ewings and consensus cell types
ewings_tsv <- file.path(
  data_dir,
  "results",
  "cell-type-ewings",
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_ewing-celltype-assignments.tsv")
)

# processed sce file
sce_file <- file.path(
  data_dir,
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_processed.rds")
)
```

### Read in data

```{r message = FALSE}
validation_df <- readr::read_tsv(validation_tsv) |>
  dplyr::filter(diagnosis == "Ewing sarcoma")

celltype_df <- readr::read_tsv(ewings_tsv) |>
  dplyr::select(barcodes, consensus_annotation, ewing_annotation)

immune_ref_barcodes <- readr::read_rds(immune_ref_sce_file) |>
  colnames() |>
  stringr::str_split_i("-", 2)
subset_ref_barcodes <- readr::read_rds(subset_ref_sce_file) |>
  colnames() |>
  stringr::str_split_i("-", 2)

# note these tsvs already have an indicator column for the reference
# the `subcluster` contains the inferCNV-calculated clusters
infercnv_df <- readr::read_tsv(immune_hmm_tsv) |>
  dplyr::bind_rows(
    readr::read_tsv(subset_hmm_tsv)
  ) |>
  dplyr::mutate(
    barcodes = stringr::str_remove(cell_id, glue::glue("{params$library_id}-")),
    # add indicator columns for whether the cell is reference or query
    is_immune_reference = barcodes %in% immune_ref_barcodes,
    is_subset_reference = barcodes %in% subset_ref_barcodes
  )

# Read SCE and create data frame with full results
cnv_df <- readr::read_rds(sce_file) |>
  scuttle::makePerCellDF(use.dimred = "UMAP") |>
  # replace UMAP.1 with UMAP1
  dplyr::rename_with(
    \(x) stringr::str_replace(x, "^UMAP\\.", "UMAP")
  ) |>
  # add in hmm results
  dplyr::left_join(infercnv_df, by = "barcodes") |>
  # add in cell type results
  dplyr::left_join(celltype_df) |>
  # remove MT and GL chromosomes
  dplyr::select(
    -contains("chrMT"),
    -contains("chrGL")
  )
```


## InferCNV Heatmaps

Below, we show the `inferCNV` heatmaps from the `immune-all` and `immune-subset` normal references for this library.

### Reference with all immune cells

![InferCNV heatmap with immune-all reference](`r immune_png`)

### Reference with a subset of immune cells 

![InferCNV heatmap with immune-subset reference](`r immune_png`)



## Distribution of CNVs per cell

This section contains figures showing the total number of CNVs detected per cell. 

### CNVs in reference vs query cells

The figures below compare the number of CNVs per cell between reference and query cells. 
Ideally, we'll see a bimodal distribution where reference cells are at/near zero, and there is a peak of higher values which may represent tumor cells.
In the density plots below, distributions are colored based on whether the cells are in the reference or not (aka, query cells).

```{r}
# grab any columns that have has_cnv
has_cnv_cols <- names(cnv_df)[stringr::str_starts(names(cnv_df), "has_cnv")]

per_cell_cnv_df <- cnv_df |>
  dplyr::mutate(total_cnv_per_cell = rowSums(dplyr::across(dplyr::all_of(has_cnv_cols)))) |>
  dplyr::rename(infercnv_cluster = subcluster)
```


```{r fig.width = 10, fig.height = 5}
all_plot <- per_cell_cnv_df |>
  dplyr::filter(normal_reference == "all-immune") |>
  dplyr::rename(in_reference = is_immune_reference) |>
  ggplot() +
  aes(x = total_cnv_per_cell, fill = in_reference) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Immune-all reference"
  ) +
  theme(legend.position = "bottom")

subset_plot <- per_cell_cnv_df |>
  dplyr::filter(normal_reference == "subset-immune") |>
  dplyr::rename(in_reference = is_subset_reference) |>
  ggplot() +
  aes(x = total_cnv_per_cell, fill = in_reference) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Immune-subset reference"
  ) +
  theme(legend.position = "bottom")

wrap_plots(all_plot, subset_plot, guides = "collect") +
  plot_annotation(title = "Total CNVs per cell") &
  theme(legend.position = "bottom")
```

### CNVs across cell types

Next, we'll look at the per-cell distributions of CNVs across cell types.
Specifically, we'll look at both the cell types from the `cell-type-consensus` module and the `cell-type-ewings` module separately.
Ideally, we'll see that Unknown cells from `cell-type-consensus` and cells labeled as tumor in `cell-type-ewings` will have relatively higher CNV scores compared to other cell types.

```{r fig.height=10, fig.width=12, message=FALSE, warning=FALSE}
consensus_violin <- ggplot(per_cell_cnv_df) +
  aes(
    x = consensus_annotation,
    y = total_cnv_per_cell,
    fill = normal_reference
  ) +
  geom_violin(scale = "width") +
  scale_fill_brewer(palette = "Pastel2") +
  labs(title = "Annotations from cell-type-consensus") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ewings_violin <- ggplot(per_cell_cnv_df) +
  aes(
    x = ewing_annotation,
    y = total_cnv_per_cell,
    fill = normal_reference
  ) +
  geom_violin(scale = "width") +
  scale_fill_brewer(palette = "Pastel2") +
  labs(title = "Annotations from cell-type-ewings") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

wrap_plots(consensus_violin, ewings_violin, ncol = 1, guides = "collect") +
  plot_annotation(title = "CNV scores across cell types") &
  theme(legend.position = "bottom")
```



## UMAPs

Next, we'll visualize the total CNV counts as a UMAP.

First, as a guide, let's look at the top 10 `cell-type-ewings` cell types.


```{r}
per_cell_cnv_df |>
  # arbitrary filtering, this is just data
  dplyr::filter(normal_reference == "all-immune") |>
  ggplot() +
  aes(x = UMAP1, y = UMAP2, color = forcats::fct_lump(ewing_annotation, 8)) +
  geom_point(size = 0.1, alpha = 0.3) +
  facet_wrap(vars(normal_reference)) +
  labs(color = "annotation") +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1))) +
  umap_theme
```
Next, the total CNVs per cell; ideally, higher values will overlap with regions in the UMAP containing putative tumor cells.

```{r fig.width=10}
ggplot(per_cell_cnv_df) +
  aes(x = UMAP1, y = UMAP2, color = total_cnv_per_cell) +
  geom_point(size = 0.1, alpha = 0.3) +
  scale_color_viridis_c() +
  facet_wrap(vars(normal_reference)) +
  labs(title = "Total CNV per cell") +
  umap_theme
```

## Clusters

Part of `inferCNV`'s algorithm involves clustering the data, and poor clusters have the potential to lead to inaccurate inferences of CNV. 
To see whether we'd like to further tune the clustering parameters, we'll get a size of some of their properties here:


How many cells are there per cluster?
Clusters labeled `reference_` contain only normal reference cells, and clusters labeled `unknown_` contain the query cells.

```{r}
cells_per_cluster <- per_cell_cnv_df |>
  dplyr::count(infercnv_cluster, normal_reference)

ggplot(cells_per_cluster) +
  aes(
    x = infercnv_cluster, # keep in default order so "reference" and "unknown" are grouped
    y = n
  ) +
  geom_col() +
  facet_wrap(
    vars(normal_reference),
    scales = "free_x"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
# How many CNV per cell per cluster?
ggplot(per_cell_cnv_df) +
  aes(x = infercnv_cluster, y = total_cnv_per_cell) +
  geom_point(size = 2) +
  facet_wrap(
    vars(normal_reference),
    scales = "free_x"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



## CNV across chromosomes

We want to look across chrs now, specifically:

```{r}
validation_df
```

```{r}
cnv_validation_df <- per_cell_cnv_df |>
  dplyr::select(
    barcodes,
    infercnv_cluster,
    total_cnv_per_cell,
    normal_reference,
    is_immune_reference,
    is_subset_reference,
    all_of(
      c(
        glue::glue("proportion_scaled_cnv_chr{1:22}"),
        glue::glue("proportion_scaled_loss_chr{1:22}"),
        glue::glue("proportion_scaled_dupli_chr{1:22}")
      )
    )
  ) |>
  tidyr::pivot_longer(
    starts_with("proportion_scaled_"),
    names_to = "cnv_type_raw",
    values_to = "proportion"
  ) |>
  dplyr::mutate(cnv_type_raw = stringr::str_remove(cnv_type_raw, "^proportion_scaled_")) |>
  tidyr::separate(cnv_type_raw, into = c("cnv_type", "chr")) |>
  dplyr::mutate(chr = stringr::str_remove(chr, "^chr"), chr = as.numeric(chr))
```

```{r}
cnv_validation_df |>
  dplyr::filter(normal_reference == "subset-immune") |>
  ggplot() +
  aes(
    x = proportion,
    color = is_subset_reference
  ) +
  geom_density() +
  facet_wrap(vars(chr))


cnv_validation_df |>
  dplyr::group_by(
    normal_reference,
    cnv_type,
    chr
  ) |>
  dplyr::summarize(median_proportion = median(proportion)) |>
  dplyr::arrange(cnv_type)
```

## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
