---
title: "`r glue::glue('inferCNV results for {params$library_id} with {params$reference_name} reference')`"
author: "Stephanie J. Spielman"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    code_folding: hide
params:
  library_id: SCPCL000822
  sample_id: SCPCS000490
  reference_name: ref_endo
---


## Introduction

This notebook explores `inferCNV` results run on library `r params$library_id` from `SCPCP000015`.

```{r, results = 'asis'}
ref_text <- list(
  "ref_endo" = "endothelial",
  "ref_immune" = "immune",
  "ref_endo-immune" = "endothelial and immune"
)
glue::glue(
  "`inferCNV` was run with the following normal reference: `{params$reference_name}`.
  This reference contains all {ref_text[[params$reference_name]]}  cells across `SCPCP000015` libraries, excluding any which were also identified as tumor in the `cell-type-ewings` analysis module.
  "
)
```


## Setup

```{r}
options(readr.show_col_types = FALSE)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(ggplot2)
  library(patchwork)
})

theme_set(theme_bw())

umap_theme <- list(
  coord_fixed(),
  theme_classic(),
  theme(
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )
)
```


### Paths

#### Base directories

```{r base paths}
# repo and analysis base dirs
repository_base <- rprojroot::find_root(rprojroot::is_git_root)
analysis_dir <- file.path(repository_base, "analyses", "infercnv-consensus-cell-type")

# OpenScpCA data and results directories
data_dir <- file.path(repository_base, "data", "current")

# inferCNV directory
infercnv_dir <- file.path(
  analysis_dir,
  "results",
  "SCPCP000015",
  params$sample_id,
  params$reference_name
)
```

#### Input files

```{r paths}
# TSV with expected Ewing CNVs
validation_tsv <- file.path(analysis_dir, "references", "cnv-validation.tsv")

# immune cell URL
immune_url <- "https://raw.githubusercontent.com/AlexsLemonade/OpenScPCA-analysis/refs/heads/main/analyses/cell-type-consensus/references/consensus-immune-cell-types.tsv"

# processed sce file
sce_file <- file.path(
  data_dir,
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_processed.rds")
)

# ewing module cell types
ewings_tsv <- file.path(
  data_dir,
  "results",
  "cell-type-ewings",
  "SCPCP000015",
  params$sample_id,
  glue::glue("{params$library_id}_ewing-celltype-assignments.tsv")
)

# infercnv files
infercnv_tsv <- file.path(
  infercnv_dir,
  glue::glue("{params$library_id}_cnv-metadata.tsv")
)
infercnv_png <- file.path(
  infercnv_dir,
  glue::glue("{params$library_id}_infercnv.png")
)
```

### Read in data

```{r message = FALSE}
validation_df <- readr::read_tsv(validation_tsv) |>
  dplyr::filter(diagnosis == "Ewing sarcoma")

immune_labels <- readr::read_tsv(immune_url) |>
  dplyr::pull(consensus_annotation)

endo_labels <- c(
  "endothelial cell",
  "blood vessel endothelial cell",
  "microvascular endothelial cell"
)

# read infercnv results
infercnv_df <- readr::read_tsv(infercnv_tsv) |>
  # indicator for reference vs query cell based on `subcluster` name
  dplyr::mutate(cell_group = stringr::str_split_i(subcluster, "_", 1)) |>
  # separate barcode and library
  tidyr::separate(
    cell_id,
    sep = "-",
    into = c("library_id", "barcodes"),
    remove = FALSE
  )


# Extract a version of the data frame with just the infercnv metadata, not CNVs themselves
infercnv_metadata_df <- infercnv_df |>
  dplyr::select(
    -starts_with("has_"),
    -starts_with("proportion_"),
    -starts_with("top_")
  )

# Read SCE and save UMAP coordinates
umap_df <- readr::read_rds(sce_file) |>
  scuttle::makePerCellDF(use.dimred = "UMAP") |>
  dplyr::select(
    barcodes,
    UMAP1 = UMAP.1,
    UMAP2 = UMAP.2
  )

# Define cell types based on ewing module
celltype_df <- readr::read_tsv(ewings_tsv) |>
  # Label cells as:
  # - tumor-immune: Cells labeled as tumor by cell-type-ewings, but immune by cell-type-consensus
  # - tumor-endo: Cells labeled as tumor by cell-type-ewings, but endothelial by cell-type-consensus
  # - tumor: Cells labeled as tumor by cell-type-ewings
  # - their existing ewing_annotation if none of the above
  dplyr::mutate(
    celltype = dplyr::case_when(
      ## tumor-immune
      consensus_annotation %in% immune_labels &
        stringr::str_starts(ewing_annotation, "tumor") ~ "tumor-immune",
      ## tumor-endo
      consensus_annotation %in% endo_labels &
        stringr::str_starts(ewing_annotation, "tumor") ~ "tumor-endo",
      ## tumor
      stringr::str_starts(ewing_annotation, "tumor") ~ "tumor",
      ## default
      .default = ewing_annotation
    )
  ) |>
  dplyr::select(barcodes, celltype)

umap_df <- umap_df |>
  dplyr::left_join(celltype_df)
```


## InferCNV Heatmap

Below, we show the `inferCNV` heatmap for this library.
To help contextualize this image, here is the table of known CNVs in Ewing sarcoma used for validation:

```{r}
validation_df
```


![InferCNV heatmap](`r infercnv_png`)


## Distribution of CNVs per cell

This section contains figures showing the total number of CNVs detected per cell.

### CNVs in reference vs query cells

The figures below compare the number of CNVs per cell between reference and query cells.
Ideally, we'll see a bimodal distribution where reference cells are at/near zero, and there is a peak of higher values which may represent tumor cells.
In the density plots below, distributions are colored based on whether the cells are in the reference or not (aka, "unknown" cells).

```{r}
# First, construct data frame of total `has_cnv` counts, with other variables needed for plots
has_cnv_df <- infercnv_df |>
  dplyr::select(
    barcodes,
    starts_with("has_cnv_")
  ) |>
  tidyr::pivot_longer(
    starts_with("has_cnv_"),
    names_to = "chr",
    values_to = "cnv"
  ) |>
  # sum all values for each
  dplyr::group_by(barcodes) |>
  dplyr::summarize(total_cnv_per_cell = sum(cnv)) |>
  dplyr::ungroup() |>
  # bring back metadata
  dplyr::inner_join(
    infercnv_metadata_df,
    by = "barcodes"
  ) |>
  # join in SCE information
  dplyr::left_join(umap_df)
```


```{r fig.width = 10, fig.height = 5}
ggplot(has_cnv_df) +
  aes(x = total_cnv_per_cell, fill = cell_group) +
  geom_density(alpha = 0.5) +
  theme(legend.position = "bottom")
```

### CNVs across cell types

Next, we'll look at the per-cell distributions of CNVs across cell types, using labels derived from the `cell-type-ewings` module as follows:

* `tumor-endo`: Cells labeled as tumor by cell-type-ewings, but endothelial by `cell-type-consensus`
* `tumor-immune`: Cells labeled as tumor by cell-type-ewings, but immune by `cell-type-consensus`
* `tumor`: Cells labeled as tumor by `cell-type-ewings`
* `endo`: An endothelial cell type
* `immune`: An immune cell type
* If none of the above, their existing `cell-type-ewings` annotation

Ideally, we'll see that tumor and Unknown cells from will have relatively higher CNV scores compared to other cell types, in particular those cell types in the reference.

```{r fig.height=12, message=FALSE, warning=FALSE}
# drop cells from other libraries
query_has_cnv_df <- has_cnv_df |>
  dplyr::filter(library_id == params$library_id)

ggplot(query_has_cnv_df) +
  aes(
    y = celltype,
    x = total_cnv_per_cell,
    fill = cell_group
  ) +
  ggridges::geom_density_ridges2(alpha = 0.7, scale = 0.85)
```


## UMAPs

Next, we'll visualize the total CNV counts as a UMAP.
Below, the UMAP colored by cell type is shown on the left, and the UMAP colored by total CNV counts is shown on the right.
Ideally, unknown and tumor cells will overlap with regions in the UMAP with higher total CNV.


```{r, fig.height = 10}
celltype_umap <- ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = celltype) +
  geom_point(size = 0.1, alpha = 0.3) +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1))) +
  labs(title = "Cell types") +
  umap_theme

cnv_umap <- ggplot(query_has_cnv_df) +
  aes(x = UMAP1, y = UMAP2, color = total_cnv_per_cell) +
  geom_point(size = 0.1, alpha = 0.3) +
  scale_color_viridis_c() +
  labs(title = "Total CNV per cell") +
  umap_theme

celltype_umap / cnv_umap
```


## Clusters

Part of `inferCNV`'s algorithm involves clustering the data, and poor clusters have the potential to lead to inaccurate inferences of CNV.
To see whether we'd like to further tune the clustering parameters, we'll get a sense of their size and rough composition here.

How many clusters are there, and how big are they?
We'll show this separately for reference vs query cells.

```{r}
cluster_count_df <- has_cnv_df |>
  dplyr::count(subcluster, cell_group)
ggplot(cluster_count_df) +
  aes(x = n, fill = cell_group) +
  geom_histogram(color = "grey20", bins = 15) +
  facet_wrap(vars(cell_group), scales = "free")
```

Is there any relationship between cluster size and the number of CNVs?
We would ideally not want there to be a relationship since this might indicate a bias.

```{r}
cluster_size_df <- has_cnv_df |>
  dplyr::add_count(subcluster, name = "cluster_size") |>
  dplyr::select(
    total_cnv_per_cell,
    cluster_size
  ) |>
  dplyr::distinct()

ggplot(cluster_size_df) +
  aes(x = cluster_size, y = total_cnv_per_cell) +
  geom_point() +
  geom_smooth(method = "lm")
```


Let's also look more specifically at the `reference` clusters, where we might expect some batch effects since cells were taken from several different libraries.
Do originating libraries cluster together?
When interpreting this plot, bear in mind that there might also be an association between cell types and libraries, and we would expect cell types to still cluster together.

```{r}
reference_cells_df <- has_cnv_df |>
  dplyr::filter(cell_group == "reference")

ggplot(reference_cells_df) +
  aes(x = subcluster, fill = library_id) +
  geom_bar() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_blank()
  )
```


## CNV across chromosomes

Now, we'll look at CNVs across chromosomes, specifically considering the `proportion_scaled_cnv_` output from the HMM.

Again, these are the specific CNVs we expect to see in Ewing sarcoma:

```{r}
validation_df
```

```{r}
# First, construct data frame with proportion_scaled_ instead of has_cnv
prop_cnv_df <- infercnv_df |>
  dplyr::select(
    library_id,
    barcodes,
    starts_with("proportion_scaled_")
  ) |>
  tidyr::pivot_longer(
    starts_with("proportion_scaled_"),
    names_to = "cnv_type_raw",
    values_to = "proportion"
  ) |>
  # more tidying
  dplyr::mutate(cnv_type_raw = stringr::str_remove(cnv_type_raw, "^proportion_scaled_")) |>
  tidyr::separate(cnv_type_raw, sep = "_", into = c("cnv_type", "chr")) |>
  # remove extra chromosomes and cells not in this library
  dplyr::filter(
    !stringr::str_starts(chr, "chrMT"),
    !stringr::str_starts(chr, "chrGL"),
    library_id == params$library_id
  ) |>
  dplyr::mutate(
    chr = stringr::str_remove(chr, "^chr"),
    # set factor levels
    chr = factor(chr, levels = 1:22),
    chr = forcats::fct_relevel(chr, as.character(validation_df$chromosome))
  )
```

We'll make density plots of the predicted CNV events across chromosomes:
The panels will be ordered first by the chromosomes with known CNVs, and then in order for the rest of the chromosomes.


```{r fig.height=12, fig.width=14}
ggplot(prop_cnv_df) +
  aes(x = proportion, color = cnv_type) +
  geom_density() +
  facet_wrap(
    vars(chr),
    scales = "free",
    ncol = 6
  ) +
  theme(strip.text = element_text(size = 8))
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
