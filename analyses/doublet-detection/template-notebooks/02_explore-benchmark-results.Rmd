---
params: 
  dataset: "hm-6k"
title: "`r glue::glue('Doublet benchmarking results: {params$dataset}')`"
author: Stephanie J. Spielman
date: "`r Sys.Date()`"
output: 
  html_notebook:
    toc: true
    toc_depth: 4
    code_folding: hide
---

The goal of this notebook is to explore doublet inferences run on ground-truth benchmarking data. 
These three doublet detection methods are explored. 

- `scDblFinder`
- `scrublet`
- A version of `cxds` [calculated by `scDblFinder`](https://github.com/plger/scDblFinder/blob/893c958322df5a4b3d364f28ed818c740de16316/R/misc.R#L268-L274).
Unlike the other two methods, this method reports only a score and does not attempt to make single/doublet calls, so we use thresholds of 0.5, 0.75, and 0.9 threshold to make `cxds` calls.

This notebook explores inferences made on a single dataset at a time (here, **`r params$dataset`**) with the goal of examining the relationship between scores and accuracy of calls (if made) compared to the ground-truth values.
Note that ground-truth calls are available only for heterotypic doublets, which these methods are more tuned for in the first place (vs homotypic).

## Dataset description

The following dataset description is adapted from [Xi and Li (2021)](https://doi.org/10.1016/j.cels.2020.11.008).

```{r results = "asis"}
if (params$dataset == "hm-6k") {
  data_desc <- "The `hm-6k` dataset is a mixture of human HEK293T and mouse NIH3T3 cells with 6806 droplets."
} else if (params$dataset == "HMEC-orig-MULTI") {
  data_desc <- "The `HMEC-orig-MULTI` dataset contains human primary mammary epithelial cells (HMECs) with 26426 droplets."
} else if (params$dataset == "pdx-MULTI") {
  data_desc <- "The `pdx-MULTI` dataset is a mixture of human breast cancer cells and mouse immune cells from a PDX mouse model."
} else if (params$dataset == "pbmc-1B-dm") {
  data_desc <- "The `pbmc-1B-dm` dataset is a PMBC sample from a patient with systemic lupus erythematosus."
} else {
  stop("Unknown dataset provided.")
}

data_desc |>
  glue::glue() |>
  print()
```



## Setup

### Packages


```{r packages}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(readr)
  library(ggplot2)
  library(patchwork)
  library(caret)
})

theme_set(theme_bw())
```

### Paths


#### Base directories

```{r base paths}
module_base <- rprojroot::find_root(rprojroot::is_renv_project)
data_dir <- file.path(module_base, "scratch", "benchmark-datasets", params$dataset)
result_dir <- file.path(module_base, "results", "benchmark-results")
```

#### Input and output files

Set paths to input and output directories and files in the chunk below.

```{r paths}
# doublet calls
scdbl_tsv <- file.path(
  result_dir, 
  glue::glue("{params$dataset}_scdblfinder.tsv")
)
scrub_tsv <- file.path(
  result_dir, 
  glue::glue("{params$dataset}_scrublet.tsv")
)

# SCE, with ground truth included
sce_file <- file.path(
  data_dir, 
  glue::glue("{params$dataset}_sce.rds")
)

```

### Functions

This chunk defines functions to explore doublet detection results.


```{r functions}
print_doublet_table <- function(df, pred_col, is_ground_truth = FALSE) {
  # Function to print a table of doublet counts and a sentence stating the percentage of doublets
  # df is expected to contain `pred_col`, should should be provided as a string
  dub_table <- table(df[[pred_col]])
  dub_percent <- round(dub_table[["doublet"]]/sum(dub_table), 4) * 100
  
  print(dub_table)
  
  if (is_ground_truth) {
    output <- glue::glue("{dub_percent}% of droplets in this dataset are doublets.") 
  } else {
    output <- glue::glue("{dub_percent}% of droplets in this dataset were predicted to be doublets.")
  }
  
  return(output)
}

plot_pca_d <- function(df, color_column, color_lab) {
  # Plot PC with a discrete color variable, showing doublets on top
  # df is expected to contain columns PC1, PC2, and `color_column`
  # The `color_column` argument should _not_ be provided as a string
  ggplot(doublet_df) + 
    aes(x = PC1, 
        y = PC2, 
        color = {{color_column}}) +
  geom_point(alpha = 0.5) + 
  scale_color_manual(values = c("black", "lightblue")) + 
  # ensure doublets are on top for visibility
  geom_point(
    data = dplyr::filter(doublet_df, {{color_column}} == "doublet"), 
    color = "black"
  ) + 
  labs(color = color_lab) + 
  theme(
    legend.title.position = "top",
    legend.position = "bottom"
  )
}


plot_pca_c <- function(df, color_column, pred_column, color_lab) {
  # Plot PC with a continuous color variable, showing doublets on top
  # df is expected to contain columns PC1, PC2, `color_column`, and `pred_column`
  # The `color_column` and `pred_column` arguments should _not_ be provided as strings
  ggplot(doublet_df) + 
    aes(x = PC1, 
        y = PC2, 
        color = {{color_column}}) +
  geom_point(alpha = 0.5) + 
  scale_color_viridis_c(direction = -1) + 
  # ensure doublets are on top for visibility
  geom_point(
    data = dplyr::filter(doublet_df, {{pred_column}} == "doublet"), 
    aes(color = {{color_column}})
  ) + 
  labs(color = color_lab) + 
  theme(
    legend.title.position = "top",
    legend.position = "bottom"
  )
}

plot_jitter_scores <- function(df, score_col, pred_col, method_name){
  # Plot jitter plot of score distributions and predictions, colored by ground truth
  # df is expected to contain columns `ground_truth`, `score_col`, and `pred_col`
  # The column arguments should _not_ be provided as strings
  ggplot(df) +
    aes(x = ground_truth,
        y = {{score_col}}, 
        color = {{pred_col}}) + 
    geom_jitter(
      alpha = 0.2, 
      width = 0.1
    ) + 
    labs(
      x = "Ground truth",
      y = glue::glue("{method_name} score"),
      color = glue::glue("{method_name} prediction")
    ) + 
  theme(
    legend.title.position = "top",
    legend.position = "bottom"
  )
}


plot_density_scores <- function(df, score_col, method_name){
  # Plot density plot of score distributions, colored by ground truth
  # df is expected to contain columns `ground_truth` and `score_col`
  # The column arguments should _not_ be provided as strings
  ggplot(df) +
    aes(x = {{score_col}}, 
        fill = ground_truth) + 
    geom_density(alpha = 0.7) + 
    labs(
      x = glue::glue("{method_name} score"),
      fill = "Ground truth call"
    ) + 
  theme(
    legend.title.position = "top",
    legend.position = "bottom"
  )
}

assess_doublets <- function(df, pred_col) {
  # df is expected to contain columns `ground_truth` and `pred_col`
  # The `pred_col` argument _should_ be provided as a strings
  
  caret::confusionMatrix(
    # truth should be first
    table(
      "Truth" = doublet_df$ground_truth,
      "Prediction" = doublet_df[[pred_col]]
    ), 
    positive = "doublet"
  )
  
}

```


### Read and prepare input data

First, we'll read in and combine TSV files with doublet results.

```{r}
scdbl_df <- read_tsv(scdbl_tsv) |>
  dplyr::select(
    barcodes,
    cxds_score, 
    scdbl_score = score, 
    scdbl_prediction  = class
  ) |>
  # add cxds calls at three thresholds:
  # 0.5, 0.75, 0.9
  dplyr::mutate(
    cxds_prediction_0.5 = dplyr::if_else(
      cxds_score >= 0.5,
      "doublet",
      "singlet"
    ),
    cxds_prediction_0.75 = dplyr::if_else(
      cxds_score >= 0.75,
      "doublet",
      "singlet"
    ),
    cxds_prediction_0.9 = dplyr::if_else(
      cxds_score >= 0.9,
      "doublet",
      "singlet"
    )
  )

scrub_df <- read_tsv(scrub_tsv) 

# grab ground truth and PCA coordinates
sce <- read_rds(sce_file)
sce_df <- scuttle::makePerCellDF(sce, use.dimred = "PCA") |>
  tibble::rownames_to_column(var = "barcodes") |>
  dplyr::select(barcodes,
                ground_truth = ground_truth_doublets, 
                PC1 = PCA.1, 
                PC2 = PCA.2)

# we can now remove the sce
rm(sce)

doublet_df <- dplyr::left_join(
  scdbl_df,
  scrub_df, 
  by = "barcodes"
) |>
  dplyr::left_join(
    sce_df, 
    by = "barcodes"
  )
```


## Ground truth

First, we assess the ground truth doublet distributions to contextualize the doublet calls.


```{r}
percent <- print_doublet_table(doublet_df, "ground_truth", is_ground_truth = TRUE)
```

```{r results = "asis"}
percent
```

```{r}
plot_pca_d(doublet_df, ground_truth, "Ground truth doublets")
```


## Doublet predictions and score distributions

Both `scDblFinder` and `scrublet` make doublet calls based on an internally-determined threshold, which may not be optimal. 
These sections explore the score distributions and how they relate to calls, including:

- PCAs of predicted doublet vs. singlets
  - The first PCA is colored by doublet scores, where scores closer to 1 are more likely to be doublets
  - The second PCA is colored by doublet predictions made by the given method and/or threshold.
- Jitter plots of doublet scores
- A confusion with associated performance metrics
  - We're particularly interested in "Balanced accuracy," as there is a much higher proportion of singlets vs doublets.

### scDblFinder results

```{r}
percent <- print_doublet_table(doublet_df, "scdbl_prediction")
```

```{r results = "asis"}
percent
```

#### Score distributions relative to ground truth

```{r}
plot_density_scores(
  doublet_df, 
  scdbl_score, 
  "scDblFinder"
)
```

#### PCA plots

```{r fig.width = 8}
d_plot <- plot_pca_d(
  doublet_df, 
  scdbl_prediction,
  "scDblFinder prediction"
)
  
c_plot <- plot_pca_c(
  doublet_df, 
  scdbl_score,
  scdbl_prediction,
  "scDblFinder score"
)
  
d_plot + c_plot
```

#### Jitter plot

```{r}
plot_jitter_scores(
  doublet_df,
  scdbl_score,
  scdbl_prediction,
  "scDblFinder prediction"
)
```


#### Confusion matrix and performance metrics

```{r}
assess_doublets(
  doublet_df,
  "scdbl_prediction"
) |>
  print()
```


### scrublet results


```{r}
percent <- print_doublet_table(doublet_df, "scrublet_prediction")
```

```{r results = "asis"}
percent
```

#### Score distributions relative to ground truth

```{r}
plot_density_scores(
  doublet_df, 
  scrublet_score, 
  "scrublet"
)
```


#### PCA plots

```{r fig.width = 8}
d_plot <- plot_pca_d(
  doublet_df, 
  scrublet_prediction,
  "scrublet prediction"
)
  
c_plot <- plot_pca_c(
  doublet_df, 
  scrublet_score,
  scrublet_prediction,
  "scrublet score"
)
  
d_plot + c_plot
```


#### Confusion matrix and performance metrics

```{r}
assess_doublets(
  doublet_df,
  "scrublet_prediction"
) |>
  print()
```


### cxds results


Since this method does not call droplets as singlet/doublet, performance is assessed below at several thresholds: 0.5, 0.75, and 0.9.


#### Score distributions relative to ground truth

```{r}
plot_density_scores(
  doublet_df, 
  cxds_score, 
  "cxds"
)
```

#### PCA plots

```{r fig.width = 10}

cxds_cols <- names(doublet_df)[grep("^cxds_prediction_", names(doublet_df))]

prediction_pcas <- cxds_cols |>
  purrr::map(
    \(col_name) {
      threshold <- stringr::str_remove(col_name, "cxds_prediction_")
        
      plot_pca_d(
        doublet_df, 
        !!as.symbol(col_name),
        glue::glue("cxds prediction at {threshold}")
      ) +
      labs(title = glue::glue("cxds prediction at {threshold}"))
    }
)
wrap_plots(prediction_pcas)
```

```{r}
# just need a single score pca for this case
# we'll provide the least stringent predictions; this only affects point layering in the plot
pca_c <- plot_pca_c(
  doublet_df, 
  cxds_score, 
  cxds_prediction_0.5,
  glue::glue("cxds scores")
)
wrap_plots(pca_c)
```



#### cxds: 0.5 threshold

```{r}
percent <- print_doublet_table(doublet_df, "cxds_prediction_0.5")
```

```{r results = "asis"}
percent
```


##### Jitter plot

```{r}
plot_jitter_scores(
  doublet_df,
  cxds_score,
  cxds_prediction_0.5,
  "cxds prediction at 0.5"
)
```


##### Confusion matrix and performance metrics

```{r}
assess_doublets(
  doublet_df,
  "cxds_prediction_0.5"
) |>
  print()
```


#### cxds: 0.75 threshold

```{r}
percent <- print_doublet_table(doublet_df, "cxds_prediction_0.75")
```

```{r results = "asis"}
percent
```

##### Jitter plot


```{r}
plot_jitter_scores(
  doublet_df,
  cxds_score,
  cxds_prediction_0.75,
  "cxds prediction at 0.75"
)
```


##### Confusion matrix and performance metrics

```{r}
assess_doublets(
  doublet_df,
  "cxds_prediction_0.75"
) |>
  print()
```

#### cxds: 0.9 threshold

```{r}
percent <- print_doublet_table(doublet_df, "cxds_prediction_0.9")
```

```{r results = "asis"}
percent
```

##### Jitter plot

```{r}
plot_jitter_scores(
  doublet_df,
  cxds_score,
  cxds_prediction_0.9,
  "cxds prediction at 0.9"
)
```

##### Confusion matrix and performance metrics

```{r}
assess_doublets(
  doublet_df,
  "cxds_prediction_0.9"
) |>
  print()
```


## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
