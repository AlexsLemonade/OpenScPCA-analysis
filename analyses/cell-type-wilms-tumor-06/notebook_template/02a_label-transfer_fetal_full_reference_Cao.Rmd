---
title: "Reference label transfer from the fetal full reference (Cao et al.) for `r params$sample_id`"
author: "Maud PLASCHKA"
date: '2024-08-07'
params:
  scpca_project_id: "SCPCP000006"
  sample_id: "SCPCS000176"
  seed: 12345
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: hide
    highlight: pygments
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      warnings=FALSE)
```


## Introduction

The aim is to perform label transfer as a step of the annotation of the Wilms tumor dataset for the sample `param$sample_id` =

```{r}
params$sample_id
```

The use of the right reference is crucial.
It is recommended that the cell types in the reference is representative to the cell types to be annotated in the query.

Wilms tumors can contain up to three histologies that resemble fetal kidney: blastema, stroma, and epithelia [1-2].
Because of their histological similarity to fetal kidneys, Wilms tumors are thought to arise from developmental derangements in embryonic renal progenitors.

We thus decided to test and compare fetal (kidney) references that could be use in the analysis module.
You can find below the two references that we plan to use


### Human fetal kidney atlas Stewart et al.

Stewart et al. created and a human fetal kidney atlas.
We will use `Azimuth` to transfer label into the Wilms tumor samples.
You can find more about the human kidney atlas here: https://www.kidneycellatlas.org/ [3]

### Azimuth Human fetal atlas Cao et al.

Azimuth also provide a human fetal atlas as a reference [4].

The data can be found on Zenodo:
https://zenodo.org/records/4738021#.YJIW4C2ZNQI

The reference contain cells from 15 organs including kidney from fetal samples.
Here we will use `Azimuth` to transfer labels from the reference.


In this notebook, we perform label transfer from the human fetal Azimuth reference from Cao et al.


### Packages

Load required packages in the following chunk, if needed.
Do not install packages here; only load them with the `library()` function.

```{r packages, message=FALSE, warning=FALSE}
library("Seurat")
library(SeuratData)
library(sctransform)
library(Azimuth)
library(SCpubr)
library(tidyverse)
library(patchwork)
library(SingleCellExperiment)

set.seed(params$seed)
```


### Define function

Here we define a function `RunAzimuth_small` to run the `Azimuth` label transfer on small samples (< 100 cells).

We take the `source` code of the function, change some default and add the `ksmooth`parameter.

We add the parameter `ksmooth`.
`ksmooth` is not a parameter of `RunAzimuth` but need to be define as in `FindTransferAnchors`, `mapping.score.k` is reinitialized to `ksmooth`. 
If not defined here, `MappingScore`will fail

We set up the `k.weight` default to 10 (instead of 50).

We set up the `mapping.score.k` default to 80 (instead of 100).

```{r RunAzimuth_small, message=FALSE, warning=FALSE}

RunAzimuth_small <- function(query = query,
reference =reference,
query.modality = "RNA",
  annotation.levels = NULL,
  umap.name = "ref.umap",
  do.adt = FALSE,
  verbose = TRUE,
  assay = NULL,
  k.weight = 10, # or any value lower than the number of anchors/cells
  n.trees = 20,
  mapping.score.k = 80,
  ksmooth = 80 
){
    if (dir.exists(reference)) {
      reference <- LoadReference(reference)$map
    } else {
      reference <- tolower(reference)
      if (reference %in% InstalledData()$Dataset) {
        # only get the `map` object since no plotting is performed
        reference <- LoadData(reference, type = "azimuth")$map
      } else if (reference %in% AvailableData()$Dataset) {
        InstallData(reference)
        # only get the `map` object since no plotting is performed
        reference <- LoadData(reference, type = "azimuth")$map
      } else {
        possible.references <- AvailableData()$Dataset[grepl("*ref", AvailableData()$Dataset)]
        print("Choose one of:")
        print(possible.references)
        stop(paste("Could not find a reference for", reference))
      }
      # handle expected new parameters in uwot models beginning in v0.1.13
      if (!"num_precomputed_nns" %in% names(Misc(reference[["refUMAP"]])$model)) {
        Misc(reference[["refUMAP"]], slot="model")$num_precomputed_nns <- 1
      }
      key.pattern = "^[^_]*_"
      new.colnames <- gsub(pattern = key.pattern, 
                           replacement = Key(reference[["refDR"]]), 
                           x = colnames(Loadings(
                             object = reference[["refDR"]],
                             projected = FALSE)))
      colnames(Loadings(object = reference[["refDR"]], 
                        projected = FALSE)) <- new.colnames
    }
    dims <- as.double(slot(reference, "neighbors")$refdr.annoy.neighbors@alg.info$ndim)
    if (isTRUE(do.adt) && !("ADT" %in% Assays(reference))) {
      warning("Cannot impute an ADT assay because the reference does not have antibody data")
      do.adt = FALSE
    }
    reference.version <- ReferenceVersion(reference)
    azimuth.version <- as.character(packageVersion(pkg = "Azimuth"))
    seurat.version <- as.character(packageVersion(pkg = "Seurat"))
    meta.data <- names(slot(reference, "meta.data"))
    
    # is annotation levels are not specify, gather all levels of annotation
    if (is.null(annotation.levels)) {
      annotation.levels <- names(slot(object = reference, name = "meta.data"))
      annotation.levels <- annotation.levels[!grepl(pattern = "^nCount", x = annotation.levels)]
      annotation.levels <- annotation.levels[!grepl(pattern = "^nFeature", x = annotation.levels)]
      annotation.levels <- annotation.levels[!grepl(pattern = "^ori", x = annotation.levels)]
    }
    
    # Change the file path based on where the query file is located on your system.
    query <- ConvertGeneNames(
      object = query,
      reference.names = rownames(x = reference),
      homolog.table = 'https://seurat.nygenome.org/azimuth/references/homologs.rds'
    )
    
    # Calculate nCount_RNA and nFeature_RNA if the query does not
    # contain them already
    if (!all(c("nCount_RNA", "nFeature_RNA") %in% c(colnames(x = query[[]])))) {
      calcn <- as.data.frame(x = Seurat:::CalcN(object = query[["RNA"]]))
      colnames(x = calcn) <- paste(
        colnames(x = calcn),
        assay,
        sep = '_'
      )
      query <- AddMetaData(
        object = query,
        metadata = calcn
      )
      rm(calcn)
    }
    
    # Calculate percent mitochondrial genes if the query contains genes
    # matching the regular expression "^MT-"
    if (any(grepl(pattern = '^MT-', x = rownames(x = query)))) {
      query <- PercentageFeatureSet(
        object = query,
        pattern = '^MT-',
        col.name = 'percent.mt',
        assay = assay
      )
    }
    # Find anchors between query and reference
    anchors <- FindTransferAnchors(
      reference = reference,
      query = query,
      k.filter =  NA,
      reference.neighbors = "refdr.annoy.neighbors",
      reference.assay = "refAssay",
      query.assay = assay,
      reference.reduction = "refDR",
      normalization.method = "SCT",
      features = rownames(Loadings(reference[["refDR"]])),
      dims = 1:dims,
      n.trees = n.trees,
      mapping.score.k = mapping.score.k,
      verbose = verbose
    )
    # Transferred labels are in metadata columns named "predicted.*"
    # The maximum prediction score is in a metadata column named "predicted.*.score"
    # The prediction scores for each class are in an assay named "prediction.score.*"
    # The imputed assay is named "impADT" if computed
    refdata <- lapply(X = annotation.levels, function(x) {
      reference[[x, drop = TRUE]]
    })
    names(x = refdata) <- annotation.levels
    
    if (isTRUE(do.adt)) {
      refdata[["impADT"]] <- GetAssayData(
        object = reference[["ADT"]],
        slot = "data"
      )
    }
    
    query <- TransferData(
      reference = reference,
      query = query,
      query.assay = assay,
      dims = 1:dims,
      anchorset = anchors,
      refdata = refdata,
      n.trees = 20,
      store.weights = TRUE,
      k.weight = k.weight,
      verbose = verbose
    )
    # Calculate the embeddings of the query data on the reference SPCA
    query <- IntegrateEmbeddings(
      anchorset = anchors,
      reference = reference,
      query = query,
      query.assay = assay,
      reductions = "pcaproject",
      reuse.weights.matrix = TRUE,
      verbose = verbose
    )
    # Calculate the query neighbors in the reference
    # with respect to the integrated embeddings
    query[["query_ref.nn"]] <- FindNeighbors(
      object = Embeddings(reference[["refDR"]]),
      query = Embeddings(query[["integrated_dr"]]),
      return.neighbor = TRUE,
      l2.norm = TRUE,
      verbose = verbose
    )
    # The reference used in the app is downsampled compared to the reference on which
    # the UMAP model was computed. This step, using the helper function NNTransform,
    # corrects the Neighbors to account for the downsampling.
    query <- Azimuth:::NNTransform(
      object = query,
      meta.data = reference[[]]
    )
    # Project the query to the reference UMAP.
    query[[umap.name]] <- RunUMAP(
      object = query[["query_ref.nn"]],
      reduction.model = reference[["refUMAP"]],
      reduction.key = 'UMAP_',
      verbose = verbose
    )
    
    # Calculate mapping score and add to metadata
    query <- AddMetaData(
      object = query,
      metadata = MappingScore(anchors = anchors, ndim = dims,  ksmooth = 80),
      col.name = "mapping.score"
    )
    
}
  
```





### Base directories

```{r base paths, eval=TRUE, include=TRUE}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
repository_base <- rprojroot::find_root(rprojroot::is_git_root)

# The path to this module
module_base <- file.path(repository_base, "analyses", "cell-type-wilms-tumor-06")
```


### Input files

#### Reference

We install and load the reference using `Azimuth`.
```{r path_to_reference}
#Check the names of the Azimuth available data and reference
AvailableData()

# Install the fetal reference
InstallData("fetusref")

ref <- SeuratData::LoadData("fetusref", type = "azimuth")
```

#### Query

In this notebook, we test the label transfer from the azimuth fetal atlas (reference) to the Wilms tumor sample defined in `params$sample_id` from the Wilms tumor dataset `param$scpca_project_id`.

We work with the pre-processed `Seurat`object saved in the `results` directory.

```{r path_to_query}
data_dir <- file.path(module_base, "results", params$sample_id)
```

### Output file

Reports will be saved in the `notebook/02-reference` directory.
The pre-processed and annotated `Seurat` object per samples are saved in the `result` folder.
```{r path_to_output}
output_dir <- file.path(module_base, "results", params$sample_id)
```

## Analysis

### Load the pre-process data (query)

```{r load, message=FALSE, warning=FALSE}
# open the processed rds object
srat <- readRDS(file.path(data_dir, paste0("01-Seurat_", params$sample_id,".Rds")))
```


### Label transfer from fetal kidney reference using Azimuth

```{r run_azimuth, message=FALSE, warnings=FALSE}
DefaultAssay(srat) <- "RNA"
options(future.globals.maxSize= 891289600000000)


if(dim(srat)[2] < 100){
 s <- RunAzimuth_small(srat, reference ="fetusref", k.weight = 10, mapping.score.k = 80, ksmooth = 80)
} else {
 s <- RunAzimuth(srat, reference ="fetusref")

}

# We transfer the annotation to the pre-processed `Seurat`iobject as we don't want to keep changes done on the query by `RunAzimuth`
metadata_vec <- c("predicted.annotation.l1.score", "predicted.annotation.l1", "predicted.annotation.l2.score", "predicted.annotation.l2", "predicted.organ.score", "predicted.organ")

metadata_to_trasfer <- s@meta.data[, metadata_vec]

srat <- AddMetaData(srat, metadata_to_trasfer, col.name = paste0("fetal_full_", metadata_vec))
```

```{r plot_azimuth, fig.height=15, fig.width=8, warnings=FALSE}

d1 <- DimPlot(srat, reduction = "umap", dims = c(1,2), group.by = "fetal_full_predicted.organ", label = TRUE, repel = TRUE) + NoLegend()
d2 <- DimPlot(srat, reduction = "umap", dims = c(1,2), group.by = "fetal_full_predicted.annotation.l1", label = TRUE, repel = TRUE) + NoLegend()
d3 <- DimPlot(srat, reduction = "umap", dims = c(1,2), group.by = "fetal_full_predicted.annotation.l2", label = TRUE, repel = TRUE) + NoLegend()

f1 <- SCpubr::do_BarPlot(sample = srat,
                         group.by = "fetal_full_predicted.organ",
                         split.by = "seurat_clusters",
                         position = "fill",
                         font.size = 10,
                         legend.ncol = 4) +
                         ggtitle("% cells")+
                         xlab(params$sample_id)

f2 <- SCpubr::do_BarPlot(sample = srat,
                         group.by = "fetal_full_predicted.annotation.l1",
                         split.by = "seurat_clusters",
                         position = "fill",
                         font.size = 10,
                         legend.ncol = 2) +
                         ggtitle("% cells")+
                         xlab(params$sample_id)

f3 <- SCpubr::do_BarPlot(sample = srat,
                         group.by = "fetal_full_predicted.annotation.l2",
                         split.by = "seurat_clusters",
                         position = "fill",
                         font.size = 10,
                         legend.ncol = 2) +
                         ggtitle("% cells")+
                         xlab(params$sample_id)

((d1/f1) | (d2/f2) )
```

## Save the `Seurat`object

```{r save}
saveRDS(object = srat, file = file.path(output_dir, paste0("02a-fetal_full_label-transfer_",params$sample_id,".Rds")))
```

## Session info

```{r }
sessionInfo()
```


## References

- [1] https://www.ncbi.nlm.nih.gov/books/NBK373356/

- [2] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9915828/

- [3] https://www.science.org/doi/10.1126/science.aat5031

- [4] https://www.science.org/doi/10.1126/science.aba7721